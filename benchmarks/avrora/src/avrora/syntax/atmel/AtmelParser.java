/* Generated By:JavaCC: Do not edit this line. AtmelParser.java */
package avrora.syntax.atmel;

import avrora.syntax.*;
import java.io.InputStream;
import java.io.Reader;
import java.util.Enumeration;
import java.util.Vector;

import cck.parser.SimpleCharStream;

public class AtmelParser extends AbstractParser implements AtmelParserConstants {

    public AtmelParser(InputStream stream, Module m, String fname) {
        this(new FileMarkingTokenManager(new SimpleCharStream(stream, 1, 1), fname));

        module = m;
    }

    /* Begin GRAMMAR */

    public void Module() throws ParseException {
        label_1:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case ADD:
                case ADC:
                case ADIW:
                case AND:
                case ANDI:
                case ASR:
                case BCLR:
                case BLD:
                case BRBC:
                case BRBS:
                case BRCC:
                case BRCS:
                case BREAK:
                case BREQ:
                case BRGE:
                case BRHC:
                case BRHS:
                case BRID:
                case BRIE:
                case BRLO:
                case BRLT:
                case BRMI:
                case BRNE:
                case BRPL:
                case BRSH:
                case BRTC:
                case BRTS:
                case BRVC:
                case BRVS:
                case BSET:
                case BST:
                case CALL:
                case CBI:
                case CBR:
                case CLC:
                case CLH:
                case CLI:
                case CLN:
                case CLR:
                case CLS:
                case CLT:
                case CLV:
                case CLZ:
                case COM:
                case CP:
                case CPC:
                case CPI:
                case CPSE:
                case DEC:
                case EICALL:
                case EIJMP:
                case ELPM:
                case EOR:
                case FMUL:
                case FMULS:
                case FMULSU:
                case ICALL:
                case IJMP:
                case IN:
                case INC:
                case JMP:
                case LD:
                case LDD:
                case LDI:
                case LDS:
                case LPM:
                case LSL:
                case LSR:
                case MOV:
                case MOVW:
                case MUL:
                case MULS:
                case MULSU:
                case NEG:
                case NOP:
                case OR:
                case ORI:
                case OUT:
                case POP:
                case PUSH:
                case RCALL:
                case RET:
                case RETI:
                case RJMP:
                case ROL:
                case ROR:
                case SBC:
                case SBCI:
                case SBI:
                case SBIC:
                case SBIS:
                case SBIW:
                case SBR:
                case SBRC:
                case SBRS:
                case SEC:
                case SEH:
                case SEI:
                case SEN:
                case SER:
                case SES:
                case SET:
                case SEV:
                case SEZ:
                case SLEEP:
                case SPM:
                case ST:
                case STD:
                case STS:
                case SUB:
                case SUBI:
                case SWAP:
                case TST:
                case WDR:
                case IDENTIFIER:
                case 149:
                case 151:
                case 152:
                case 153:
                case 154:
                case 155:
                case 156:
                case 157:
                case 159:
                case 160:
                case 161:
                case 162:
                case 163:
                    break;
                default:
                    jj_la1[0] = jj_gen;
                    break label_1;
            }
            Statement();
        }
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case 0:
                jj_consume_token(0);
                break;
            case 158:
                ExitDirective();
                break;
            default:
                jj_la1[1] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void Statement() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case 149:
            case 151:
            case 152:
            case 153:
            case 154:
            case 155:
            case 156:
            case 157:
            case 159:
            case 160:
            case 161:
            case 162:
            case 163:
                Directive();
                break;
            case ADD:
            case ADC:
            case ADIW:
            case AND:
            case ANDI:
            case ASR:
            case BCLR:
            case BLD:
            case BRBC:
            case BRBS:
            case BRCC:
            case BRCS:
            case BREAK:
            case BREQ:
            case BRGE:
            case BRHC:
            case BRHS:
            case BRID:
            case BRIE:
            case BRLO:
            case BRLT:
            case BRMI:
            case BRNE:
            case BRPL:
            case BRSH:
            case BRTC:
            case BRTS:
            case BRVC:
            case BRVS:
            case BSET:
            case BST:
            case CALL:
            case CBI:
            case CBR:
            case CLC:
            case CLH:
            case CLI:
            case CLN:
            case CLR:
            case CLS:
            case CLT:
            case CLV:
            case CLZ:
            case COM:
            case CP:
            case CPC:
            case CPI:
            case CPSE:
            case DEC:
            case EICALL:
            case EIJMP:
            case ELPM:
            case EOR:
            case FMUL:
            case FMULS:
            case FMULSU:
            case ICALL:
            case IJMP:
            case IN:
            case INC:
            case JMP:
            case LD:
            case LDD:
            case LDI:
            case LDS:
            case LPM:
            case LSL:
            case LSR:
            case MOV:
            case MOVW:
            case MUL:
            case MULS:
            case MULSU:
            case NEG:
            case NOP:
            case OR:
            case ORI:
            case OUT:
            case POP:
            case PUSH:
            case RCALL:
            case RET:
            case RETI:
            case RJMP:
            case ROL:
            case ROR:
            case SBC:
            case SBCI:
            case SBI:
            case SBIC:
            case SBIS:
            case SBIW:
            case SBR:
            case SBRC:
            case SBRS:
            case SEC:
            case SEH:
            case SEI:
            case SEN:
            case SER:
            case SES:
            case SET:
            case SEV:
            case SEZ:
            case SLEEP:
            case SPM:
            case ST:
            case STD:
            case STS:
            case SUB:
            case SUBI:
            case SWAP:
            case TST:
            case WDR:
                Instruction();
                break;
            case IDENTIFIER:
                Label();
                break;
            default:
                jj_la1[2] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void Directive() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case 149:
                EquDirective();
                break;
            case 151:
                OrgDirective();
                break;
            case 152:
                ReserveDirective();
                break;
            case 153:
            case 154:
            case 155:
                DataDirective();
                break;
            case 156:
                DefDirective();
                break;
            case 157:
                IncludeDirective();
                break;
            case 159:
                NoListDirective();
                break;
            case 160:
                ListDirective();
                break;
            case 161:
            case 162:
            case 163:
                SegDirective();
                break;
            default:
                jj_la1[3] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void Instruction() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ADD:
            case ADC:
            case AND:
            case CP:
            case CPC:
            case CPSE:
            case EOR:
            case FMUL:
            case FMULS:
            case FMULSU:
            case MOV:
            case MOVW:
            case MUL:
            case MULS:
            case MULSU:
            case OR:
            case SBC:
            case SUB:
                InstrGPRGPR();
                break;
            case ASR:
            case CLR:
            case COM:
            case DEC:
            case INC:
            case LSL:
            case LSR:
            case NEG:
            case POP:
            case PUSH:
            case ROL:
            case ROR:
            case SER:
            case SWAP:
            case TST:
                InstrGPR();
                break;
            case ADIW:
            case ANDI:
            case BLD:
            case BST:
            case CBR:
            case CPI:
            case ORI:
            case SBCI:
            case SBIW:
            case SBR:
            case SBRC:
            case SBRS:
            case SUBI:
                InstrGPRIMM();
                break;
            case BCLR:
            case BRCC:
            case BRCS:
            case BREQ:
            case BRGE:
            case BRHC:
            case BRHS:
            case BRID:
            case BRIE:
            case BRLO:
            case BRLT:
            case BRMI:
            case BRNE:
            case BRPL:
            case BRSH:
            case BRTC:
            case BRTS:
            case BRVC:
            case BRVS:
            case BSET:
            case CALL:
            case JMP:
            case RCALL:
            case RJMP:
                InstrIMM();
                break;
            case BRBC:
            case BRBS:
            case CBI:
            case SBI:
            case SBIC:
            case SBIS:
                InstrIMMIMM();
                break;
            case BREAK:
            case CLC:
            case CLH:
            case CLI:
            case CLN:
            case CLS:
            case CLT:
            case CLV:
            case CLZ:
            case EICALL:
            case EIJMP:
            case ICALL:
            case IJMP:
            case NOP:
            case RET:
            case RETI:
            case SEC:
            case SEH:
            case SEI:
            case SEN:
            case SES:
            case SET:
            case SEV:
            case SEZ:
            case SLEEP:
            case SPM:
            case WDR:
                InstrBARE();
                break;
            case ELPM:
            case LD:
            case LDD:
            case LDI:
            case LDS:
            case LPM:
                InstrLoad();
                break;
            case ST:
            case STD:
            case STS:
                InstrStore();
                break;
            case IN:
                InstrInput();
                break;
            case OUT:
                InstrOutput();
                break;
            default:
                jj_la1[4] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void InstrGPRGPR() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = OpcodeGPRGPR();
        r1 = Register();
        jj_consume_token(145);
        r2 = Register();
        module.addInstruction(t.image, t, r1, r2);
    }

    public Token OpcodeGPRGPR() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ADD:
                t = jj_consume_token(ADD);
                break;
            case ADC:
                t = jj_consume_token(ADC);
                break;
            case SUB:
                t = jj_consume_token(SUB);
                break;
            case SBC:
                t = jj_consume_token(SBC);
                break;
            case AND:
                t = jj_consume_token(AND);
                break;
            case OR:
                t = jj_consume_token(OR);
                break;
            case EOR:
                t = jj_consume_token(EOR);
                break;
            case MUL:
                t = jj_consume_token(MUL);
                break;
            case MULS:
                t = jj_consume_token(MULS);
                break;
            case MULSU:
                t = jj_consume_token(MULSU);
                break;
            case FMUL:
                t = jj_consume_token(FMUL);
                break;
            case FMULS:
                t = jj_consume_token(FMULS);
                break;
            case FMULSU:
                t = jj_consume_token(FMULSU);
                break;
            case CPSE:
                t = jj_consume_token(CPSE);
                break;
            case CP:
                t = jj_consume_token(CP);
                break;
            case CPC:
                t = jj_consume_token(CPC);
                break;
            case MOV:
                t = jj_consume_token(MOV);
                break;
            case MOVW:
                t = jj_consume_token(MOVW);
                break;
            default:
                jj_la1[5] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrGPR() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        t = OpcodeGPR();
        r1 = Register();
        module.addInstruction(t.image, t, r1);
    }

    public Token OpcodeGPR() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case COM:
                t = jj_consume_token(COM);
                break;
            case NEG:
                t = jj_consume_token(NEG);
                break;
            case INC:
                t = jj_consume_token(INC);
                break;
            case DEC:
                t = jj_consume_token(DEC);
                break;
            case TST:
                t = jj_consume_token(TST);
                break;
            case CLR:
                t = jj_consume_token(CLR);
                break;
            case SER:
                t = jj_consume_token(SER);
                break;
            case PUSH:
                t = jj_consume_token(PUSH);
                break;
            case POP:
                t = jj_consume_token(POP);
                break;
            case LSL:
                t = jj_consume_token(LSL);
                break;
            case LSR:
                t = jj_consume_token(LSR);
                break;
            case ROL:
                t = jj_consume_token(ROL);
                break;
            case ROR:
                t = jj_consume_token(ROR);
                break;
            case ASR:
                t = jj_consume_token(ASR);
                break;
            case SWAP:
                t = jj_consume_token(SWAP);
                break;
            default:
                jj_la1[6] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrGPRIMM() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = OpcodeGPRIMM();
        r1 = Register();
        jj_consume_token(145);
        c1 = Const();
        module.addInstruction(t.image, t, r1, c1);
    }

    public Token OpcodeGPRIMM() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ADIW:
                t = jj_consume_token(ADIW);
                break;
            case SUBI:
                t = jj_consume_token(SUBI);
                break;
            case SBCI:
                t = jj_consume_token(SBCI);
                break;
            case SBIW:
                t = jj_consume_token(SBIW);
                break;
            case ANDI:
                t = jj_consume_token(ANDI);
                break;
            case ORI:
                t = jj_consume_token(ORI);
                break;
            case SBR:
                t = jj_consume_token(SBR);
                break;
            case CBR:
                t = jj_consume_token(CBR);
                break;
            case CPI:
                t = jj_consume_token(CPI);
                break;
            case SBRC:
                t = jj_consume_token(SBRC);
                break;
            case SBRS:
                t = jj_consume_token(SBRS);
                break;
            case BST:
                t = jj_consume_token(BST);
                break;
            case BLD:
                t = jj_consume_token(BLD);
                break;
            default:
                jj_la1[7] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrIMM() throws ParseException {
        Token t;
        SyntacticOperand.Expr c1;
        t = OpcodeIMM();
        c1 = Const();
        module.addInstruction(t.image, t, c1);
    }

    public Token OpcodeIMM() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case RJMP:
                t = jj_consume_token(RJMP);
                break;
            case JMP:
                t = jj_consume_token(JMP);
                break;
            case RCALL:
                t = jj_consume_token(RCALL);
                break;
            case CALL:
                t = jj_consume_token(CALL);
                break;
            case BREQ:
                t = jj_consume_token(BREQ);
                break;
            case BRNE:
                t = jj_consume_token(BRNE);
                break;
            case BRCS:
                t = jj_consume_token(BRCS);
                break;
            case BRCC:
                t = jj_consume_token(BRCC);
                break;
            case BRSH:
                t = jj_consume_token(BRSH);
                break;
            case BRLO:
                t = jj_consume_token(BRLO);
                break;
            case BRMI:
                t = jj_consume_token(BRMI);
                break;
            case BRPL:
                t = jj_consume_token(BRPL);
                break;
            case BRGE:
                t = jj_consume_token(BRGE);
                break;
            case BRLT:
                t = jj_consume_token(BRLT);
                break;
            case BRHS:
                t = jj_consume_token(BRHS);
                break;
            case BRHC:
                t = jj_consume_token(BRHC);
                break;
            case BRTS:
                t = jj_consume_token(BRTS);
                break;
            case BRTC:
                t = jj_consume_token(BRTC);
                break;
            case BRVS:
                t = jj_consume_token(BRVS);
                break;
            case BRVC:
                t = jj_consume_token(BRVC);
                break;
            case BRIE:
                t = jj_consume_token(BRIE);
                break;
            case BRID:
                t = jj_consume_token(BRID);
                break;
            case BSET:
                t = jj_consume_token(BSET);
                break;
            case BCLR:
                t = jj_consume_token(BCLR);
                break;
            default:
                jj_la1[8] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrIMMIMM() throws ParseException {
        Token t;
        SyntacticOperand.Expr c1, c2;
        t = OpcodeIMMIMM();
        c1 = Const();
        jj_consume_token(145);
        c2 = Const();
        module.addInstruction(t.image, t, c1, c2);
    }

    public Token OpcodeIMMIMM() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case SBIC:
                t = jj_consume_token(SBIC);
                break;
            case SBIS:
                t = jj_consume_token(SBIS);
                break;
            case BRBS:
                t = jj_consume_token(BRBS);
                break;
            case BRBC:
                t = jj_consume_token(BRBC);
                break;
            case SBI:
                t = jj_consume_token(SBI);
                break;
            case CBI:
                t = jj_consume_token(CBI);
                break;
            default:
                jj_la1[9] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrLoad() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case LDI:
                InstrLDI();
                break;
            case LD:
                InstrLD_variant();
                break;
            case LDD:
                InstrLDD();
                break;
            case LDS:
                InstrLDS();
                break;
            case ELPM:
            case LPM:
                InstrLPM_variant();
                break;
            default:
                jj_la1[10] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void InstrLDI() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(LDI);
        r1 = Register();
        jj_consume_token(145);
        c1 = Const();
        module.addInstruction(t.image, t, r1, c1);
    }

    public void InstrLD_variant() throws ParseException {
        if (jj_2_1(5)) {
            InstrLDPI();
        } else if (jj_2_2(4)) {
            InstrLDPD();
        } else {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case LD:
                    InstrLD();
                    break;
                default:
                    jj_la1[11] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    public void InstrLD() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(LD);
        r1 = Register();
        jj_consume_token(145);
        r2 = Register();
        module.addInstruction("ld", t, r1, r2);
    }

    public void InstrLDPI() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(LD);
        r1 = Register();
        jj_consume_token(145);
        r2 = Register();
        jj_consume_token(146);
        module.addInstruction("ldpi", t, r1, r2);
    }

    public void InstrLDPD() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(LD);
        r1 = Register();
        jj_consume_token(145);
        jj_consume_token(147);
        r2 = Register();
        module.addInstruction("ldpd", t, r1, r2);
    }

    public void InstrLDD() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(LDD);
        r1 = Register();
        jj_consume_token(145);
        r2 = Register();
        jj_consume_token(146);
        c1 = Const();
        module.addInstruction(t.image, t, r1, r2, c1);
    }

    public void InstrLDS() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(LDS);
        r1 = Register();
        jj_consume_token(145);
        c1 = Const();
        module.addInstruction(t.image, t, r1, c1);
    }

    public void InstrLPM_variant() throws ParseException {
        if (jj_2_3(5)) {
            InstrLPMGPRGPRP();
        } else if (jj_2_4(3)) {
            InstrLPMGPRGPR();
        } else {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case ELPM:
                case LPM:
                    InstrLPMBARE();
                    break;
                default:
                    jj_la1[12] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    public void InstrLPMGPRGPR() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = OpcodeLPM();
        r1 = Register();
        jj_consume_token(145);
        r2 = Register();
        module.addInstruction(t.image + 'd', t, r1, r2);
    }

    public void InstrLPMGPRGPRP() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = OpcodeLPM();
        r1 = Register();
        jj_consume_token(145);
        r2 = Register();
        jj_consume_token(146);
        module.addInstruction(t.image + "pi", t, r1, r2);
    }

    public void InstrLPMBARE() throws ParseException {
        Token t;
        t = OpcodeLPM();
        module.addInstruction(t.image, t);
    }

    public Token OpcodeLPM() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case LPM:
                t = jj_consume_token(LPM);
                break;
            case ELPM:
                t = jj_consume_token(ELPM);
                break;
            default:
                jj_la1[13] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrStore() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ST:
                InstrST_variant();
                break;
            case STD:
                InstrSTD();
                break;
            case STS:
                InstrSTS();
                break;
            default:
                jj_la1[14] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void InstrST_variant() throws ParseException {
        if (jj_2_5(3)) {
            InstrST();
        } else if (jj_2_6(3)) {
            InstrSTPI();
        } else {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case ST:
                    InstrSTPD();
                    break;
                default:
                    jj_la1[15] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    public void InstrST() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(ST);
        r1 = Register();
        jj_consume_token(145);
        r2 = Register();
        module.addInstruction("st", t, r1, r2);
    }

    public void InstrSTPI() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(ST);
        r1 = Register();
        jj_consume_token(146);
        jj_consume_token(145);
        r2 = Register();
        module.addInstruction("stpi", t, r1, r2);
    }

    public void InstrSTPD() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(ST);
        jj_consume_token(147);
        r1 = Register();
        jj_consume_token(145);
        r2 = Register();
        module.addInstruction("stpd", t, r1, r2);
    }

    public void InstrSTD() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(STD);
        r1 = Register();
        jj_consume_token(146);
        c1 = Const();
        jj_consume_token(145);
        r2 = Register();
        module.addInstruction(t.image, t, r1, c1, r2);
    }

    public void InstrSTS() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(STS);
        c1 = Const();
        jj_consume_token(145);
        r1 = Register();
        module.addInstruction(t.image, t, c1, r1);
    }

    public void InstrBARE() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case IJMP:
                t = jj_consume_token(IJMP);
                break;
            case ICALL:
                t = jj_consume_token(ICALL);
                break;
            case RET:
                t = jj_consume_token(RET);
                break;
            case RETI:
                t = jj_consume_token(RETI);
                break;
            case SEC:
                t = jj_consume_token(SEC);
                break;
            case CLC:
                t = jj_consume_token(CLC);
                break;
            case SEN:
                t = jj_consume_token(SEN);
                break;
            case CLN:
                t = jj_consume_token(CLN);
                break;
            case SEZ:
                t = jj_consume_token(SEZ);
                break;
            case CLZ:
                t = jj_consume_token(CLZ);
                break;
            case SEI:
                t = jj_consume_token(SEI);
                break;
            case CLI:
                t = jj_consume_token(CLI);
                break;
            case SES:
                t = jj_consume_token(SES);
                break;
            case CLS:
                t = jj_consume_token(CLS);
                break;
            case SEV:
                t = jj_consume_token(SEV);
                break;
            case CLV:
                t = jj_consume_token(CLV);
                break;
            case SET:
                t = jj_consume_token(SET);
                break;
            case CLT:
                t = jj_consume_token(CLT);
                break;
            case SEH:
                t = jj_consume_token(SEH);
                break;
            case CLH:
                t = jj_consume_token(CLH);
                break;
            case NOP:
                t = jj_consume_token(NOP);
                break;
            case SLEEP:
                t = jj_consume_token(SLEEP);
                break;
            case WDR:
                t = jj_consume_token(WDR);
                break;
            case BREAK:
                t = jj_consume_token(BREAK);
                break;
            case SPM:
                t = jj_consume_token(SPM);
                break;
            case EIJMP:
                t = jj_consume_token(EIJMP);
                break;
            case EICALL:
                t = jj_consume_token(EICALL);
                break;
            default:
                jj_la1[16] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        module.addInstruction(t.image, t);
    }

    public void InstrInput() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(IN);
        r1 = Register();
        jj_consume_token(145);
        c1 = Const();
        module.addInstruction(t.image, t, r1, c1);
    }

    public void InstrOutput() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(OUT);
        c1 = Const();
        jj_consume_token(145);
        r1 = Register();
        module.addInstruction(t.image, t, c1, r1);
    }

    public SyntacticOperand.Register Register() throws ParseException {
        Token tok;
        tok = jj_consume_token(IDENTIFIER);
        return module.newOperand(tok);

    }

    public void Label() throws ParseException {
        Token tok;
        tok = jj_consume_token(IDENTIFIER);
        jj_consume_token(148);
        module.addLabel(tok);
    }

    public void EquDirective() throws ParseException {
        Token tok;
        Expr e;
        jj_consume_token(149);
        tok = jj_consume_token(IDENTIFIER);
        jj_consume_token(150);
        e = Expr();
        module.addConstant(tok, e);
    }

    public void OrgDirective() throws ParseException {
        Token tok;
        jj_consume_token(151);
        tok = jj_consume_token(INTEGER_LITERAL);
        module.setOrigin(new Expr.Constant(tok));
    }

    public void ReserveDirective() throws ParseException {
        Expr e;
        jj_consume_token(152);
        e = Expr();
        module.reserveBytes(e, null);
    }

    public void DataDirective() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case 153:
                ByteDirective();
                break;
            case 154:
                WordDirective();
                break;
            case 155:
                DoubleWordDirective();
                break;
            default:
                jj_la1[17] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void ByteDirective() throws ParseException {
        ExprList l;
        jj_consume_token(153);
        l = DataList();
        module.addDataBytes(l);
    }

    public void WordDirective() throws ParseException {
        ExprList l;
        jj_consume_token(154);
        l = DataList();
        module.addDataWords(l);
    }

    public void DoubleWordDirective() throws ParseException {
        ExprList l;
        jj_consume_token(155);
        l = DataList();
        module.addDataDoubleWords(l);
    }

    public void DefDirective() throws ParseException {
        Token name;
        SyntacticOperand.Register reg;
        jj_consume_token(156);
        name = jj_consume_token(IDENTIFIER);
        jj_consume_token(150);
        reg = Register();
        module.addDefinition(name, reg.name);
    }

    public void IncludeDirective() throws ParseException {
        Token file;
        jj_consume_token(157);
        file = jj_consume_token(STRING_LITERAL);
        module.includeFile(file);
    }

    public void ExitDirective() throws ParseException {
        jj_consume_token(158);
    }

    public void NoListDirective() throws ParseException {
        jj_consume_token(159);
    }

    public void ListDirective() throws ParseException {
        jj_consume_token(160);
    }

    public void SegDirective() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case 161:
                jj_consume_token(161);
                module.enterDataSegment();
                break;
            case 162:
                jj_consume_token(162);
                module.enterProgramSegment();
                break;
            case 163:
                jj_consume_token(163);
                module.enterEEPROMSegment();
                break;
            default:
                jj_la1[18] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public SyntacticOperand.Expr Const() throws ParseException {
        Expr e;
        e = Expr();
        return module.newOperand(e);

    }

    public ExprList DataList() throws ParseException {
        ExprList list = new ExprList();
        Expr e;
        e = Data();
        list.add(e);
        label_2:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 145:
                    break;
                default:
                    jj_la1[19] = jj_gen;
                    break label_2;
            }
            jj_consume_token(145);
            e = Data();
            list.add(e);
        }
        return list;

    }

    public Expr Data() throws ParseException {
        Token tok;
        Expr e;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case INTEGER_LITERAL:
            case LOW:
            case HIGH:
            case LO8:
            case HI8:
            case BYTE2:
            case BYTE3:
            case BYTE4:
            case LWRD:
            case HWRD:
            case PAGE:
            case EXP2:
            case LOG2:
            case IDENTIFIER:
            case 147:
            case 179:
            case 180:
            case 181:
                e = Expr();
                break;
            case STRING_LITERAL:
                tok = jj_consume_token(STRING_LITERAL);
                e = new Expr.StringLiteral(tok);
                break;
            default:
                jj_la1[20] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return e;

    }

    public Expr Expr() throws ParseException {
        Expr e;
        e = LorExpr();
        return e;

    }

    public Expr LorExpr() throws ParseException {
        Token tok;
        Expr e, er;
        e = LandExpr();
        label_3:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 164:
                    break;
                default:
                    jj_la1[21] = jj_gen;
                    break label_3;
            }
            tok = jj_consume_token(164);
            er = LandExpr();
            e = new Expr.BinOp(tok, e, er);
        }
        return e;

    }

    public Expr LandExpr() throws ParseException {
        Token tok;
        Expr e, er;
        e = OrExpr();
        label_4:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 165:
                    break;
                default:
                    jj_la1[22] = jj_gen;
                    break label_4;
            }
            tok = jj_consume_token(165);
            er = OrExpr();
            e = new Expr.BinOp(tok, e, er);
        }
        return e;

    }

    public Expr OrExpr() throws ParseException {
        Token tok;
        Expr e, er;
        e = XorExpr();
        label_5:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 166:
                    break;
                default:
                    jj_la1[23] = jj_gen;
                    break label_5;
            }
            tok = jj_consume_token(166);
            er = XorExpr();
            e = new Expr.BinOp(tok, e, er);
        }
        return e;

    }

    public Expr XorExpr() throws ParseException {
        Token tok;
        Expr e, er;
        e = AndExpr();
        label_6:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 167:
                    break;
                default:
                    jj_la1[24] = jj_gen;
                    break label_6;
            }
            tok = jj_consume_token(167);
            er = AndExpr();
            e = new Expr.BinOp(tok, e, er);
        }
        return e;

    }

    public Expr AndExpr() throws ParseException {
        Token tok;
        Expr e, er;
        e = EqExpr();
        label_7:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 168:
                    break;
                default:
                    jj_la1[25] = jj_gen;
                    break label_7;
            }
            tok = jj_consume_token(168);
            er = EqExpr();
            e = new Expr.BinOp(tok, e, er);
        }
        return e;

    }

    public Expr EqExpr() throws ParseException {
        Token tok;
        Expr e, er;
        e = RelExpr();
        label_8:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 169:
                case 170:
                    break;
                default:
                    jj_la1[26] = jj_gen;
                    break label_8;
            }
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 169:
                    tok = jj_consume_token(169);
                    break;
                case 170:
                    tok = jj_consume_token(170);
                    break;
                default:
                    jj_la1[27] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            er = RelExpr();
            e = new Expr.BinOp(tok, e, er);
        }
        return e;

    }

    public Expr RelExpr() throws ParseException {
        Token tok;
        Expr e, er;
        e = ShiftExpr();
        label_9:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 171:
                case 172:
                case 173:
                case 174:
                    break;
                default:
                    jj_la1[28] = jj_gen;
                    break label_9;
            }
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 171:
                    tok = jj_consume_token(171);
                    break;
                case 172:
                    tok = jj_consume_token(172);
                    break;
                case 173:
                    tok = jj_consume_token(173);
                    break;
                case 174:
                    tok = jj_consume_token(174);
                    break;
                default:
                    jj_la1[29] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            er = ShiftExpr();
            e = new Expr.BinOp(tok, e, er);
        }
        return e;

    }

    public Expr ShiftExpr() throws ParseException {
        Token tok;
        Expr e, er;
        e = AddExpr();
        label_10:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 175:
                case 176:
                    break;
                default:
                    jj_la1[30] = jj_gen;
                    break label_10;
            }
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 175:
                    tok = jj_consume_token(175);
                    break;
                case 176:
                    tok = jj_consume_token(176);
                    break;
                default:
                    jj_la1[31] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            er = AddExpr();
            e = new Expr.BinOp(tok, e, er);
        }
        return e;

    }

    public Expr AddExpr() throws ParseException {
        Token tok;
        Expr e, er;
        e = MulExpr();
        label_11:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 146:
                case 147:
                    break;
                default:
                    jj_la1[32] = jj_gen;
                    break label_11;
            }
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 146:
                    tok = jj_consume_token(146);
                    break;
                case 147:
                    tok = jj_consume_token(147);
                    break;
                default:
                    jj_la1[33] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            er = MulExpr();
            e = new Expr.BinOp(tok, e, er);
        }
        return e;

    }

    public Expr MulExpr() throws ParseException {
        Token tok;
        Expr e, er;
        e = UnaryExpr();
        label_12:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 177:
                case 178:
                    break;
                default:
                    jj_la1[34] = jj_gen;
                    break label_12;
            }
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case 177:
                    tok = jj_consume_token(177);
                    break;
                case 178:
                    tok = jj_consume_token(178);
                    break;
                default:
                    jj_la1[35] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            er = UnaryExpr();
            e = new Expr.BinOp(tok, e, er);
        }
        return e;

    }

    public Expr UnaryExpr() throws ParseException {
        Token tok;
        Expr e;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case 147:
            case 179:
            case 180:
                switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                    case 179:
                        tok = jj_consume_token(179);
                        break;
                    case 180:
                        tok = jj_consume_token(180);
                        break;
                    case 147:
                        tok = jj_consume_token(147);
                        break;
                    default:
                        jj_la1[36] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                e = UnaryExpr();
                e = new Expr.UnOp(tok, e);
                break;
            case INTEGER_LITERAL:
            case LOW:
            case HIGH:
            case LO8:
            case HI8:
            case BYTE2:
            case BYTE3:
            case BYTE4:
            case LWRD:
            case HWRD:
            case PAGE:
            case EXP2:
            case LOG2:
            case IDENTIFIER:
            case 181:
                e = Term();
                break;
            default:
                jj_la1[37] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return e;

    }

    public Expr Term() throws ParseException {
        Token tok;
        Expr e;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                tok = jj_consume_token(IDENTIFIER);
                e = new Expr.Variable(tok);
                break;
            case LOW:
            case HIGH:
            case LO8:
            case HI8:
            case BYTE2:
            case BYTE3:
            case BYTE4:
            case LWRD:
            case HWRD:
            case PAGE:
            case EXP2:
            case LOG2:
                e = Func();
                break;
            case INTEGER_LITERAL:
                tok = jj_consume_token(INTEGER_LITERAL);
                e = new Expr.Constant(tok);
                break;
            case 181:
                jj_consume_token(181);
                e = Expr();
                jj_consume_token(182);
                break;
            default:
                jj_la1[38] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return e;

    }

    public Expr Func() throws ParseException {
        Token tok;
        Token l;
        Expr e;
        tok = FuncName();
        jj_consume_token(181);
        e = Expr();
        l = jj_consume_token(182);
        return new Expr.Func(tok, e, l);

    }

    public Token FuncName() throws ParseException {
        Token tok;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case LOW:
                tok = jj_consume_token(LOW);
                break;
            case HIGH:
                tok = jj_consume_token(HIGH);
                break;
            case LO8:
                tok = jj_consume_token(LO8);
                break;
            case HI8:
                tok = jj_consume_token(HI8);
                break;
            case BYTE2:
                tok = jj_consume_token(BYTE2);
                break;
            case BYTE3:
                tok = jj_consume_token(BYTE3);
                break;
            case BYTE4:
                tok = jj_consume_token(BYTE4);
                break;
            case LWRD:
                tok = jj_consume_token(LWRD);
                break;
            case HWRD:
                tok = jj_consume_token(HWRD);
                break;
            case PAGE:
                tok = jj_consume_token(PAGE);
                break;
            case EXP2:
                tok = jj_consume_token(EXP2);
                break;
            case LOG2:
                tok = jj_consume_token(LOG2);
                break;
            default:
                jj_la1[39] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return tok;

    }

    private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        boolean retval = !jj_3_1();
        jj_save(0, xla);
        return retval;
    }

    private boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        boolean retval = !jj_3_2();
        jj_save(1, xla);
        return retval;
    }

    private boolean jj_2_3(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        boolean retval = !jj_3_3();
        jj_save(2, xla);
        return retval;
    }

    private boolean jj_2_4(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        boolean retval = !jj_3_4();
        jj_save(3, xla);
        return retval;
    }

    private boolean jj_2_5(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        boolean retval = !jj_3_5();
        jj_save(4, xla);
        return retval;
    }

    private boolean jj_2_6(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        boolean retval = !jj_3_6();
        jj_save(5, xla);
        return retval;
    }

    private boolean jj_3R_22() {
        return jj_scan_token(ELPM);
    }

    private boolean jj_3_6() {
        return jj_3R_18();
    }

    private boolean jj_3R_15() {
        if (jj_3R_20()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_3R_19()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_scan_token(145)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_3R_19()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return jj_scan_token(146);
    }

    private boolean jj_3_5() {
        return jj_3R_17();
    }

    private boolean jj_3_2() {
        return jj_3R_14();
    }

    private boolean jj_3R_16() {
        if (jj_3R_20()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_3R_19()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return jj_scan_token(145);
    }

    private boolean jj_3_1() {
        return jj_3R_13();
    }

    private boolean jj_3R_14() {
        if (jj_scan_token(LD)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_3R_19()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_scan_token(145)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return jj_scan_token(147);
    }

    private boolean jj_3R_18() {
        if (jj_scan_token(ST)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_3R_19()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return jj_scan_token(146);
    }

    private boolean jj_3R_21() {
        return jj_scan_token(LPM);
    }

    private boolean jj_3R_19() {
        return jj_scan_token(IDENTIFIER);
    }

    private boolean jj_3R_20() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_21()) {
            jj_scanpos = xsp;
            if (jj_3R_22()) return true;
            }
        return false;
    }

    private boolean jj_3_4() {
        return jj_3R_16();
    }

    private boolean jj_3_3() {
        return jj_3R_15();
    }

    private boolean jj_3R_13() {
        if (jj_scan_token(LD)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_3R_19()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_scan_token(145)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_3R_19()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return jj_scan_token(146);
    }

    private boolean jj_3R_17() {
        if (jj_scan_token(ST)) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        if (jj_3R_19()) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
        return jj_scan_token(145);
    }

    public AtmelParserTokenManager token_source;
    public Token token, jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    private int jj_gen;
    private final int[] jj_la1 = new int[40];
    private static int[] jj_la1_0;
    private static int[] jj_la1_1;
    private static int[] jj_la1_2;
    private static int[] jj_la1_3;
    private static int[] jj_la1_4;
    private static int[] jj_la1_5;

    static {
        jj_la1_0();
        jj_la1_1();
        jj_la1_2();
        jj_la1_3();
        jj_la1_4();
        jj_la1_5();
    }

    private static void jj_la1_0() {
        jj_la1_0 = new int[] { 0xf0000000, 0x1, 0xf0000000, 0x0, 0xf0000000, 0xb0000000, 0x0, 0x40000000, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfff8200, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfff0200, 0xfff0200, 0xfff0000, };
    }

    private static void jj_la1_1() {
        jj_la1_1 = new int[] { 0xffffffff, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0x2, 0x24000009, 0xbfffec4,
                0x10000030, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0000100, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
    }

    private static void jj_la1_2() {
        jj_la1_2 = new int[] { 0xffffffff, 0x0, 0xffffffff, 0x0, 0xffffffff, 0xf0b00, 0xc0801084, 0x400,
                0x1000000, 0x0, 0x3e008000, 0x2000000, 0x20008000, 0x20008000, 0x0, 0x0, 0x30607b, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, };
    }

    private static void jj_la1_3() {
        jj_la1_3 = new int[] { 0xffffffff, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x4009f, 0x80030c20, 0x7880100,
                0x9000, 0x700000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x78006040, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
    }

    private static void jj_la1_4() {
        jj_la1_4 = new int[] { 0xbfa07fff, 0x40000000, 0xbfa07fff, 0xbfa00000, 0x3fff, 0x200, 0x1800, 0x400,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1c0, 0x40, 0x203f, 0xe000000, 0x0, 0x20000, 0x84000, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0000, 0xc0000, 0x0, 0x0, 0x80000, 0x84000,
                0x4000, 0x0, };
    }

    private static void jj_la1_5() {
        jj_la1_5 = new int[] { 0xf, 0x0, 0xf, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0xe, 0x0, 0x380000, 0x10, 0x20, 0x40, 0x80, 0x100, 0x600, 0x600, 0x7800, 0x7800,
                0x18000, 0x18000, 0x0, 0x0, 0x60000, 0x60000, 0x180000, 0x380000, 0x200000, 0x0, };
    }

    private final JJCalls[] jj_2_rtns = new JJCalls[6];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    public AtmelParser(AtmelParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 40; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        return jj_scanpos.kind != kind;
    }

    private int jj_ntk() {
        if ((jj_nt = token.next) == null) return jj_ntk = (token.next = token_source.getNextToken()).kind;
        else return jj_ntk = jj_nt.kind;
    }

    private Vector jj_expentries = new Vector();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            System.arraycopy(jj_lasttokens, 0, jj_expentry, 0, jj_endpos);
            boolean exists = false;
            for (Enumeration enm = jj_expentries.elements(); enm.hasMoreElements();) {
                int[] oldentry = (int[]) enm.nextElement();
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists) break;
                }
            }
            if (!exists) jj_expentries.addElement(jj_expentry);
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[183];
        for (int i = 0; i < 183; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 40; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & 1 << j) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & 1 << j) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & 1 << j) != 0) {
                        la1tokens[64 + j] = true;
                    }
                    if ((jj_la1_3[i] & 1 << j) != 0) {
                        la1tokens[96 + j] = true;
                    }
                    if ((jj_la1_4[i] & 1 << j) != 0) {
                        la1tokens[128 + j] = true;
                    }
                    if ((jj_la1_5[i] & 1 << j) != 0) {
                        la1tokens[160 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 183; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[])jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 6; i++) {
            JJCalls p = jj_2_rtns[i];
            do {
                if (p.gen > jj_gen) {
                    jj_la = p.arg;
                    jj_lastpos = jj_scanpos = p.first;
                    switch (i) {
                        case 0:
                            jj_3_1();
                            break;
                        case 1:
                            jj_3_2();
                            break;
                        case 2:
                            jj_3_3();
                            break;
                        case 3:
                            jj_3_4();
                            break;
                        case 4:
                            jj_3_5();
                            break;
                        case 5:
                            jj_3_6();
                            break;
                    }
                }
                p = p.next;
            } while (p != null);
        }
        jj_rescan = false;
    }

    private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static class JJCalls {

        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
