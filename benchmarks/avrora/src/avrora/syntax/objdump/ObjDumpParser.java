/* Generated By:JavaCC: Do not edit this line. ObjDumpParser.java */
package avrora.syntax.objdump;

import avrora.syntax.*;
import java.io.*;
import java.util.Enumeration;
import java.util.Vector;

import cck.parser.SimpleCharStream;

public class ObjDumpParser extends AbstractParser implements ObjDumpParserConstants {

    protected RawModule rawModule;

    public ObjDumpParser(Reader stream, RawModule m, String fname) {
        this(new FileMarkingTokenManager(new SimpleCharStream(stream, 1, 1, 4096), fname));

        module = m;
        rawModule = m;
    }

    /* Begin GRAMMAR */

    public void Module() throws ParseException {
        Header();
        label_1:
        while (true) {
            Section();
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case START:
                    break;
                default:
                    jj_la1[0] = jj_gen;
                    break label_1;
            }
        }
        jj_consume_token(0);
    }

    public void Header() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case PROGRAM:
                jj_consume_token(PROGRAM);
                jj_consume_token(STRING_LITERAL);
                jj_consume_token(154);
                break;
            default:
                jj_la1[1] = jj_gen;
        }
        label_2:
        while (true) {
            SectionDecl();
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case SECTION:
                    break;
                default:
                    jj_la1[2] = jj_gen;
                    break label_2;
            }
        }
    }

    public void SectionDecl() throws ParseException {
        Token name, vma, lma;
        jj_consume_token(SECTION);
        name = jj_consume_token(DOT_IDENTIFIER);
        jj_consume_token(SIZE);
        jj_consume_token(155);
        jj_consume_token(INTEGER_LITERAL);
        jj_consume_token(VMA);
        jj_consume_token(155);
        vma = jj_consume_token(INTEGER_LITERAL);
        jj_consume_token(LMA);
        jj_consume_token(155);
        lma = jj_consume_token(INTEGER_LITERAL);
        jj_consume_token(OFFSET);
        jj_consume_token(155);
        jj_consume_token(INTEGER_LITERAL);
        rawModule.newSection(name, vma, lma);
    }

    public void Section() throws ParseException {
        Token sect;
        jj_consume_token(START);
        sect = jj_consume_token(DOT_IDENTIFIER);
        jj_consume_token(154);
        rawModule.enterSection(sect);
        label_3:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case INTEGER_LITERAL:
                case LABEL:
                    break;
                default:
                    jj_la1[3] = jj_gen;
                    break label_3;
            }
            Statement();
        }
    }

    public void Statement() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case LABEL:
                Label();
                break;
            case INTEGER_LITERAL:
                Item();
                break;
            default:
                jj_la1[4] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void Item() throws ParseException {
        Token addr;
        addr = jj_consume_token(INTEGER_LITERAL);
        jj_consume_token(154);
        rawModule.setAddress(addr);
        RawData();
        rawModule.setAddress(addr);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ADD:
            case ADC:
            case ADIW:
            case AND:
            case ANDI:
            case ASR:
            case BCLR:
            case BLD:
            case BRBC:
            case BRBS:
            case BRCC:
            case BRCS:
            case BREAK:
            case BREQ:
            case BRGE:
            case BRHC:
            case BRHS:
            case BRID:
            case BRIE:
            case BRLO:
            case BRLT:
            case BRMI:
            case BRNE:
            case BRPL:
            case BRSH:
            case BRTC:
            case BRTS:
            case BRVC:
            case BRVS:
            case BSET:
            case BST:
            case CALL:
            case CBI:
            case CBR:
            case CLC:
            case CLH:
            case CLI:
            case CLN:
            case CLR:
            case CLS:
            case CLT:
            case CLV:
            case CLZ:
            case COM:
            case CP:
            case CPC:
            case CPI:
            case CPSE:
            case DEC:
            case EICALL:
            case EIJMP:
            case ELPM:
            case EOR:
            case FMUL:
            case FMULS:
            case FMULSU:
            case ICALL:
            case IJMP:
            case IN:
            case INC:
            case JMP:
            case LD:
            case LDD:
            case LDI:
            case LDS:
            case LPM:
            case LSL:
            case LSR:
            case MOV:
            case MOVW:
            case MUL:
            case MULS:
            case MULSU:
            case NEG:
            case NOP:
            case OR:
            case ORI:
            case OUT:
            case POP:
            case PUSH:
            case RCALL:
            case RET:
            case RETI:
            case RJMP:
            case ROL:
            case ROR:
            case SBC:
            case SBCI:
            case SBI:
            case SBIC:
            case SBIS:
            case SBIW:
            case SBR:
            case SBRC:
            case SBRS:
            case SEC:
            case SEH:
            case SEI:
            case SEN:
            case SER:
            case SES:
            case SET:
            case SEV:
            case SEZ:
            case SLEEP:
            case SPM:
            case ST:
            case STD:
            case STS:
            case SUB:
            case SUBI:
            case SWAP:
            case TST:
            case WDR:
                Instruction();
                break;
            case WORD:
                Data();
                break;
            default:
                jj_la1[5] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void RawData() throws ParseException {
        if (jj_2_1(3)) {
            Raw4();
        } else {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case INTEGER_LITERAL:
                    Raw2();
                    break;
                default:
                    jj_la1[6] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    public void Raw2() throws ParseException {
        Token b1, b2;
        b1 = jj_consume_token(INTEGER_LITERAL);
        b2 = jj_consume_token(INTEGER_LITERAL);
        rawModule.addBytes(b1, b2);
    }

    public void Raw4() throws ParseException {
        Token b1, b2, b3, b4;
        b1 = jj_consume_token(INTEGER_LITERAL);
        b2 = jj_consume_token(INTEGER_LITERAL);
        b3 = jj_consume_token(INTEGER_LITERAL);
        b4 = jj_consume_token(INTEGER_LITERAL);
        rawModule.addBytes(b1, b2, b3, b4);
    }

    public void Instruction() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ADD:
            case ADC:
            case AND:
            case CP:
            case CPC:
            case CPSE:
            case EOR:
            case FMUL:
            case FMULS:
            case FMULSU:
            case MOV:
            case MOVW:
            case MUL:
            case MULS:
            case MULSU:
            case OR:
            case SBC:
            case SUB:
                InstrGPRGPR();
                break;
            case ASR:
            case CLR:
            case COM:
            case DEC:
            case INC:
            case LSL:
            case LSR:
            case NEG:
            case POP:
            case PUSH:
            case ROL:
            case ROR:
            case SER:
            case SWAP:
            case TST:
                InstrGPR();
                break;
            case ADIW:
            case ANDI:
            case BLD:
            case BST:
            case CBR:
            case CPI:
            case ORI:
            case SBCI:
            case SBIW:
            case SBR:
            case SBRC:
            case SBRS:
            case SUBI:
                InstrGPRIMM();
                break;
            case IN:
                InstrInput();
                break;
            case OUT:
                InstrOutput();
                break;
            case BCLR:
            case BRCC:
            case BRCS:
            case BREQ:
            case BRGE:
            case BRHC:
            case BRHS:
            case BRID:
            case BRIE:
            case BRLO:
            case BRLT:
            case BRMI:
            case BRNE:
            case BRPL:
            case BRSH:
            case BRTC:
            case BRTS:
            case BRVC:
            case BRVS:
            case BSET:
            case CALL:
            case JMP:
            case RCALL:
            case RJMP:
                InstrIMM();
                break;
            case BRBC:
            case BRBS:
            case CBI:
            case SBI:
            case SBIC:
            case SBIS:
                InstrIMMIMM();
                break;
            case BREAK:
            case CLC:
            case CLH:
            case CLI:
            case CLN:
            case CLS:
            case CLT:
            case CLV:
            case CLZ:
            case EICALL:
            case EIJMP:
            case ICALL:
            case IJMP:
            case NOP:
            case RET:
            case RETI:
            case SEC:
            case SEH:
            case SEI:
            case SEN:
            case SES:
            case SET:
            case SEV:
            case SEZ:
            case SLEEP:
            case SPM:
            case WDR:
                InstrBARE();
                break;
            case ELPM:
            case LD:
            case LDD:
            case LDI:
            case LDS:
            case LPM:
                InstrLoad();
                break;
            case ST:
            case STD:
            case STS:
                InstrStore();
                break;
            default:
                jj_la1[7] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void Data() throws ParseException {
        jj_consume_token(WORD);
        jj_consume_token(INTEGER_LITERAL);
    }

    public void InstrGPRGPR() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = OpcodeGPRGPR();
        r1 = Register();
        jj_consume_token(156);
        r2 = Register();
        module.addInstruction(t.image, t, r1, r2);
    }

    public Token OpcodeGPRGPR() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ADD:
                t = jj_consume_token(ADD);
                break;
            case ADC:
                t = jj_consume_token(ADC);
                break;
            case SUB:
                t = jj_consume_token(SUB);
                break;
            case SBC:
                t = jj_consume_token(SBC);
                break;
            case AND:
                t = jj_consume_token(AND);
                break;
            case OR:
                t = jj_consume_token(OR);
                break;
            case EOR:
                t = jj_consume_token(EOR);
                break;
            case MUL:
                t = jj_consume_token(MUL);
                break;
            case MULS:
                t = jj_consume_token(MULS);
                break;
            case MULSU:
                t = jj_consume_token(MULSU);
                break;
            case FMUL:
                t = jj_consume_token(FMUL);
                break;
            case FMULS:
                t = jj_consume_token(FMULS);
                break;
            case FMULSU:
                t = jj_consume_token(FMULSU);
                break;
            case CPSE:
                t = jj_consume_token(CPSE);
                break;
            case CP:
                t = jj_consume_token(CP);
                break;
            case CPC:
                t = jj_consume_token(CPC);
                break;
            case MOV:
                t = jj_consume_token(MOV);
                break;
            case MOVW:
                t = jj_consume_token(MOVW);
                break;
            default:
                jj_la1[8] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrGPR() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        t = OpcodeGPR();
        r1 = Register();
        module.addInstruction(t.image, t, r1);
    }

    public Token OpcodeGPR() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case COM:
                t = jj_consume_token(COM);
                break;
            case NEG:
                t = jj_consume_token(NEG);
                break;
            case INC:
                t = jj_consume_token(INC);
                break;
            case DEC:
                t = jj_consume_token(DEC);
                break;
            case TST:
                t = jj_consume_token(TST);
                break;
            case CLR:
                t = jj_consume_token(CLR);
                break;
            case SER:
                t = jj_consume_token(SER);
                break;
            case PUSH:
                t = jj_consume_token(PUSH);
                break;
            case POP:
                t = jj_consume_token(POP);
                break;
            case LSL:
                t = jj_consume_token(LSL);
                break;
            case LSR:
                t = jj_consume_token(LSR);
                break;
            case ROL:
                t = jj_consume_token(ROL);
                break;
            case ROR:
                t = jj_consume_token(ROR);
                break;
            case ASR:
                t = jj_consume_token(ASR);
                break;
            case SWAP:
                t = jj_consume_token(SWAP);
                break;
            default:
                jj_la1[9] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrGPRIMM() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = OpcodeGPRIMM();
        r1 = Register();
        jj_consume_token(156);
        c1 = Const();
        module.addInstruction(t.image, t, r1, c1);
    }

    public Token OpcodeGPRIMM() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ADIW:
                t = jj_consume_token(ADIW);
                break;
            case SUBI:
                t = jj_consume_token(SUBI);
                break;
            case SBCI:
                t = jj_consume_token(SBCI);
                break;
            case SBIW:
                t = jj_consume_token(SBIW);
                break;
            case ANDI:
                t = jj_consume_token(ANDI);
                break;
            case ORI:
                t = jj_consume_token(ORI);
                break;
            case SBR:
                t = jj_consume_token(SBR);
                break;
            case CBR:
                t = jj_consume_token(CBR);
                break;
            case CPI:
                t = jj_consume_token(CPI);
                break;
            case SBRC:
                t = jj_consume_token(SBRC);
                break;
            case SBRS:
                t = jj_consume_token(SBRS);
                break;
            case BST:
                t = jj_consume_token(BST);
                break;
            case BLD:
                t = jj_consume_token(BLD);
                break;
            default:
                jj_la1[10] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrIMM() throws ParseException {
        Token t;
        SyntacticOperand.Expr c1;
        t = OpcodeIMM();
        c1 = Const();
        module.addInstruction(t.image, t, c1);
    }

    public Token OpcodeIMM() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case RJMP:
                t = jj_consume_token(RJMP);
                break;
            case JMP:
                t = jj_consume_token(JMP);
                break;
            case RCALL:
                t = jj_consume_token(RCALL);
                break;
            case CALL:
                t = jj_consume_token(CALL);
                break;
            case BREQ:
                t = jj_consume_token(BREQ);
                break;
            case BRNE:
                t = jj_consume_token(BRNE);
                break;
            case BRCS:
                t = jj_consume_token(BRCS);
                break;
            case BRCC:
                t = jj_consume_token(BRCC);
                break;
            case BRSH:
                t = jj_consume_token(BRSH);
                break;
            case BRLO:
                t = jj_consume_token(BRLO);
                break;
            case BRMI:
                t = jj_consume_token(BRMI);
                break;
            case BRPL:
                t = jj_consume_token(BRPL);
                break;
            case BRGE:
                t = jj_consume_token(BRGE);
                break;
            case BRLT:
                t = jj_consume_token(BRLT);
                break;
            case BRHS:
                t = jj_consume_token(BRHS);
                break;
            case BRHC:
                t = jj_consume_token(BRHC);
                break;
            case BRTS:
                t = jj_consume_token(BRTS);
                break;
            case BRTC:
                t = jj_consume_token(BRTC);
                break;
            case BRVS:
                t = jj_consume_token(BRVS);
                break;
            case BRVC:
                t = jj_consume_token(BRVC);
                break;
            case BRIE:
                t = jj_consume_token(BRIE);
                break;
            case BRID:
                t = jj_consume_token(BRID);
                break;
            case BSET:
                t = jj_consume_token(BSET);
                break;
            case BCLR:
                t = jj_consume_token(BCLR);
                break;
            default:
                jj_la1[11] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrIMMIMM() throws ParseException {
        Token t;
        SyntacticOperand.Expr c1, c2;
        t = OpcodeIMMIMM();
        c1 = Const();
        jj_consume_token(156);
        c2 = Const();
        module.addInstruction(t.image, t, c1, c2);
    }

    public Token OpcodeIMMIMM() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case SBIC:
                t = jj_consume_token(SBIC);
                break;
            case SBIS:
                t = jj_consume_token(SBIS);
                break;
            case BRBS:
                t = jj_consume_token(BRBS);
                break;
            case BRBC:
                t = jj_consume_token(BRBC);
                break;
            case SBI:
                t = jj_consume_token(SBI);
                break;
            case CBI:
                t = jj_consume_token(CBI);
                break;
            default:
                jj_la1[12] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrLoad() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case LDI:
                InstrLDI();
                break;
            case LD:
                InstrLD_variant();
                break;
            case LDD:
                InstrLDD();
                break;
            case LDS:
                InstrLDS();
                break;
            case ELPM:
            case LPM:
                InstrLPM_variant();
                break;
            default:
                jj_la1[13] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void InstrLDI() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(LDI);
        r1 = Register();
        jj_consume_token(156);
        c1 = Const();
        module.addInstruction(t.image, t, r1, c1);
    }

    public void InstrLD_variant() throws ParseException {
        if (jj_2_2(5)) {
            InstrLDPI();
        } else if (jj_2_3(4)) {
            InstrLDPD();
        } else {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case LD:
                    InstrLD();
                    break;
                default:
                    jj_la1[14] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    public void InstrLD() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(LD);
        r1 = Register();
        jj_consume_token(156);
        r2 = Register();
        module.addInstruction("ld", t, r1, r2);
    }

    public void InstrLDPI() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(LD);
        r1 = Register();
        jj_consume_token(156);
        r2 = Register();
        jj_consume_token(157);
        module.addInstruction("ldpi", t, r1, r2);
    }

    public void InstrLDPD() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(LD);
        r1 = Register();
        jj_consume_token(156);
        jj_consume_token(158);
        r2 = Register();
        module.addInstruction("ldpd", t, r1, r2);
    }

    public void InstrLDD() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(LDD);
        r1 = Register();
        jj_consume_token(156);
        r2 = Register();
        jj_consume_token(157);
        c1 = Const();
        module.addInstruction(t.image, t, r1, r2, c1);
    }

    public void InstrLDS() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(LDS);
        r1 = Register();
        jj_consume_token(156);
        c1 = Const();
        module.addInstruction(t.image, t, r1, c1);
    }

    public void InstrLPM_variant() throws ParseException {
        if (jj_2_4(5)) {
            InstrLPMGPRGPRP();
        } else if (jj_2_5(3)) {
            InstrLPMGPRGPR();
        } else {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case ELPM:
                case LPM:
                    InstrLPMBARE();
                    break;
                default:
                    jj_la1[15] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    public void InstrLPMGPRGPR() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = OpcodeLPM();
        r1 = Register();
        jj_consume_token(156);
        r2 = Register();
        module.addInstruction(t.image + "d", t, r1, r2);
    }

    public void InstrLPMGPRGPRP() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = OpcodeLPM();
        r1 = Register();
        jj_consume_token(156);
        r2 = Register();
        jj_consume_token(157);
        module.addInstruction(t.image + "pi", t, r1, r2);
    }

    public void InstrLPMBARE() throws ParseException {
        Token t;
        t = OpcodeLPM();
        module.addInstruction(t.image, t);
    }

    public Token OpcodeLPM() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case LPM:
                t = jj_consume_token(LPM);
                break;
            case ELPM:
                t = jj_consume_token(ELPM);
                break;
            default:
                jj_la1[16] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void InstrStore() throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ST:
                InstrST_variant();
                break;
            case STD:
                InstrSTD();
                break;
            case STS:
                InstrSTS();
                break;
            default:
                jj_la1[17] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void InstrST_variant() throws ParseException {
        if (jj_2_6(3)) {
            InstrST();
        } else if (jj_2_7(3)) {
            InstrSTPI();
        } else {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case ST:
                    InstrSTPD();
                    break;
                default:
                    jj_la1[18] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    public void InstrST() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(ST);
        r1 = Register();
        jj_consume_token(156);
        r2 = Register();
        module.addInstruction("st", t, r1, r2);
    }

    public void InstrSTPI() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(ST);
        r1 = Register();
        jj_consume_token(157);
        jj_consume_token(156);
        r2 = Register();
        module.addInstruction("stpi", t, r1, r2);
    }

    public void InstrSTPD() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        t = jj_consume_token(ST);
        jj_consume_token(158);
        r1 = Register();
        jj_consume_token(156);
        r2 = Register();
        module.addInstruction("stpd", t, r1, r2);
    }

    public void InstrSTD() throws ParseException {
        Token t;
        SyntacticOperand.Register r1, r2;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(STD);
        r1 = Register();
        jj_consume_token(157);
        c1 = Const();
        jj_consume_token(156);
        r2 = Register();
        module.addInstruction(t.image, t, r1, c1, r2);
    }

    public void InstrSTS() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(STS);
        c1 = Const();
        jj_consume_token(156);
        r1 = Register();
        module.addInstruction(t.image, t, c1, r1);
    }

    public void InstrBARE() throws ParseException {
        Token t;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case IJMP:
                t = jj_consume_token(IJMP);
                break;
            case ICALL:
                t = jj_consume_token(ICALL);
                break;
            case RET:
                t = jj_consume_token(RET);
                break;
            case RETI:
                t = jj_consume_token(RETI);
                break;
            case SEC:
                t = jj_consume_token(SEC);
                break;
            case CLC:
                t = jj_consume_token(CLC);
                break;
            case SEN:
                t = jj_consume_token(SEN);
                break;
            case CLN:
                t = jj_consume_token(CLN);
                break;
            case SEZ:
                t = jj_consume_token(SEZ);
                break;
            case CLZ:
                t = jj_consume_token(CLZ);
                break;
            case SEI:
                t = jj_consume_token(SEI);
                break;
            case CLI:
                t = jj_consume_token(CLI);
                break;
            case SES:
                t = jj_consume_token(SES);
                break;
            case CLS:
                t = jj_consume_token(CLS);
                break;
            case SEV:
                t = jj_consume_token(SEV);
                break;
            case CLV:
                t = jj_consume_token(CLV);
                break;
            case SET:
                t = jj_consume_token(SET);
                break;
            case CLT:
                t = jj_consume_token(CLT);
                break;
            case SEH:
                t = jj_consume_token(SEH);
                break;
            case CLH:
                t = jj_consume_token(CLH);
                break;
            case NOP:
                t = jj_consume_token(NOP);
                break;
            case SLEEP:
                t = jj_consume_token(SLEEP);
                break;
            case WDR:
                t = jj_consume_token(WDR);
                break;
            case BREAK:
                t = jj_consume_token(BREAK);
                break;
            case SPM:
                t = jj_consume_token(SPM);
                break;
            case EIJMP:
                t = jj_consume_token(EIJMP);
                break;
            case EICALL:
                t = jj_consume_token(EICALL);
                break;
            default:
                jj_la1[19] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        module.addInstruction(t.image, t);
    }

    public void InstrInput() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(IN);
        r1 = Register();
        jj_consume_token(156);
        c1 = Const();
        module.addInstruction(t.image, t, r1, c1);
    }

    public void InstrOutput() throws ParseException {
        Token t;
        SyntacticOperand.Register r1;
        SyntacticOperand.Expr c1;
        t = jj_consume_token(OUT);
        c1 = Const();
        jj_consume_token(156);
        r1 = Register();
        module.addInstruction(t.image, t, c1, r1);
    }

    public SyntacticOperand.Register Register() throws ParseException {
        Token tok;
        tok = jj_consume_token(IDENTIFIER);
        return module.newOperand(tok);

    }

    public void Label() throws ParseException {
        Token tok;
        Token v;
        jj_consume_token(LABEL);
        v = jj_consume_token(INTEGER_LITERAL);
        tok = jj_consume_token(STRING_LITERAL);
        jj_consume_token(154);
        rawModule.addQuotedLabelAt(v, tok);
    }

    public SyntacticOperand.Expr Const() throws ParseException {
        Expr e;
        if (jj_2_8(2147483647)) {
            e = RelExpr();
        } else {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case INTEGER_LITERAL:
                case IDENTIFIER:
                    e = Term();
                    break;
                default:
                    jj_la1[20] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        return module.newOperand(e);

    }

    public Expr Term() throws ParseException {
        Token tok;
        Expr e;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                tok = jj_consume_token(IDENTIFIER);
                e = new Expr.Variable(tok);
                break;
            case INTEGER_LITERAL:
                tok = jj_consume_token(INTEGER_LITERAL);
                e = new Expr.Constant(tok);
                break;
            default:
                jj_la1[21] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return e;

    }

    public Expr RelExpr() throws ParseException {
        Token ltok;
        Token op;
        Token rtok;
        ltok = jj_consume_token(159);
        op = BinOp();
        rtok = jj_consume_token(INTEGER_LITERAL);
        return new Expr.RelativeAddress(ltok, op, rtok);

    }

    public Token BinOp() throws ParseException {
        Token tok;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case 157:
                tok = jj_consume_token(157);
                break;
            case 158:
                tok = jj_consume_token(158);
                break;
            default:
                jj_la1[22] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return tok;

    }

    private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    private boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_2();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(1, xla);
        }
    }

    private boolean jj_2_3(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_3();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(2, xla);
        }
    }

    private boolean jj_2_4(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_4();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(3, xla);
        }
    }

    private boolean jj_2_5(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_5();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(4, xla);
        }
    }

    private boolean jj_2_6(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_6();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(5, xla);
        }
    }

    private boolean jj_2_7(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_7();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(6, xla);
        }
    }

    private boolean jj_2_8(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_8();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(7, xla);
        }
    }

    private boolean jj_3_3() {
        return jj_3R_6();
    }

    private boolean jj_3R_8() {
        return jj_3R_12() || jj_3R_11() || jj_scan_token(156);
    }

    private boolean jj_3_2() {
        return jj_3R_5();
    }

    private boolean jj_3R_6() {
        return jj_scan_token(LD) || jj_3R_11() || jj_scan_token(156) || jj_scan_token(158);
    }

    private boolean jj_3R_10() {
        return jj_scan_token(ST) || jj_3R_11() || jj_scan_token(157);
    }

    private boolean jj_3_1() {
        return jj_3R_4();
    }

    private boolean jj_3R_11() {
        return jj_scan_token(IDENTIFIER);
    }

    private boolean jj_3R_12() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(100)) {
            jj_scanpos = xsp;
            if (jj_scan_token(86)) return true;
        }
        return false;
    }

    private boolean jj_3_5() {
        return jj_3R_8();
    }

    private boolean jj_3_4() {
        return jj_3R_7();
    }

    private boolean jj_3_8() {
        return jj_scan_token(159);
    }

    private boolean jj_3R_5() {
        if (jj_scan_token(LD)) return true;
        if (jj_3R_11()) return true;
        if (jj_scan_token(156)) return true;
        return jj_3R_11() || jj_scan_token(157);
    }

    private boolean jj_3R_9() {
        return jj_scan_token(ST) || jj_3R_11() || jj_scan_token(156);
    }

    private boolean jj_3R_4() {
        return jj_scan_token(INTEGER_LITERAL) || jj_scan_token(INTEGER_LITERAL) || jj_scan_token(INTEGER_LITERAL);
    }

    private boolean jj_3_7() {
        return jj_3R_10();
    }

    private boolean jj_3R_7() {
        if (jj_3R_12()) return true;
        if (jj_3R_11()) return true;
        return jj_scan_token(156) || jj_3R_11() || jj_scan_token(157);
    }

    private boolean jj_3_6() {
        return jj_3R_9();
    }

    public ObjDumpParserTokenManager token_source;
    public Token token, jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    private int jj_gen;
    private final int[] jj_la1 = new int[23];
    private static int[] jj_la1_0;
    private static int[] jj_la1_1;
    private static int[] jj_la1_2;
    private static int[] jj_la1_3;
    private static int[] jj_la1_4;

    static {
        jj_la1_0();
        jj_la1_1();
        jj_la1_2();
        jj_la1_3();
        jj_la1_4();
    }

    private static void jj_la1_0() {
        jj_la1_0 = new int[] { 0x8000000, 0x20000000, 0x10000000, 0x40000200, 0x40000200, 0x4000000, 0x200,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x200, 0x200, 0x0, };
    }

    private static void jj_la1_1() {
        jj_la1_1 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0xfffffff8, 0x0, 0xfffffff8, 0x58, 0x100, 0x4a0,
                0xffff6200, 0x1800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8000, 0x0, 0x0, 0x0, };
    }

    private static void jj_la1_2() {
        jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x7858000, 0x40084200,
                0x20012, 0x80000005, 0x8, 0x400000, 0x0, 0x400000, 0x400000, 0x0, 0x0, 0x18303de0, 0x0, 0x0,
                0x0, };
    }

    private static void jj_la1_3() {
        jj_la1_3 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x2004f80, 0x1861060,
                0xc4008000, 0x480000, 0x38000000, 0x1f, 0x1, 0x10, 0x10, 0x0, 0x0, 0x302000, 0x0, 0x0, 0x0, };
    }

    private static void jj_la1_4() {
        jj_la1_4 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x1fffff, 0x0, 0x1fffff, 0x10000, 0xc0040, 0x20003,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe000, 0x2000, 0x101fbc, 0x200000, 0x200000, 0x60000000, };
    }

    private final JJCalls[] jj_2_rtns = new JJCalls[8];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    public ObjDumpParser(ObjDumpParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 23; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    private static class LookaheadSuccess extends Error {

    }

    private final LookaheadSuccess jj_ls = new LookaheadSuccess();

    private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
        return false;
    }

    private int jj_ntk() {
        if ((jj_nt = token.next) == null) return jj_ntk = (token.next = token_source.getNextToken()).kind;
        else return jj_ntk = jj_nt.kind;
    }

    private Vector jj_expentries = new Vector();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            System.arraycopy(jj_lasttokens, 0, jj_expentry, 0, jj_endpos);
            boolean exists = false;
            for (Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
                int[] oldentry = (int[]) e.nextElement();
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists) break;
                }
            }
            if (!exists) jj_expentries.addElement(jj_expentry);
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[160];
        for (int i = 0; i < 160; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 23; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & 1 << j) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & 1 << j) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & 1 << j) != 0) {
                        la1tokens[64 + j] = true;
                    }
                    if ((jj_la1_3[i] & 1 << j) != 0) {
                        la1tokens[96 + j] = true;
                    }
                    if ((jj_la1_4[i] & 1 << j) != 0) {
                        la1tokens[128 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 160; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[])jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 8; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                            case 0:
                                jj_3_1();
                                break;
                            case 1:
                                jj_3_2();
                                break;
                            case 2:
                                jj_3_3();
                                break;
                            case 3:
                                jj_3_4();
                                break;
                            case 4:
                                jj_3_5();
                                break;
                            case 5:
                                jj_3_6();
                                break;
                            case 6:
                                jj_3_7();
                                break;
                            case 7:
                                jj_3_8();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static class JJCalls {

        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
