/* Generated By:JavaCC: Do not edit this line. ISDLParser.java */
package jintgen.isdl.parser;

import jintgen.isdl.*;
import jintgen.jigir.*;
import jintgen.types.TypeRef;
import java.io.*;
import java.util.*;

public class ISDLParser implements ISDLParserConstants {

    ArchDecl arch;

    /* Begin GRAMMAR */

    public ArchDecl ArchDecl() throws ParseException {
        Token n;
        jj_consume_token(ARCHITECTURE);
        n = jj_consume_token(IDENTIFIER);
        arch = new ArchDecl(n);
        jj_consume_token(LBRACKET);
        label_1:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case INSTRUCTION:
                case FORMAT:
                case ENUM:
                case ENUM_SUB:
                case OPERAND_TYPE:
                case ADDR_MODE:
                case ADDR_SET:
                case GLOBAL:
                case SUBROUTINE:
                case INLINE:
                case EXTERNAL:
                case PSEUDO:
                    break;
                default:
                    jj_la1[0] = jj_gen;
                    break label_1;
            }
            Item();
        }
        jj_consume_token(RBRACKET);
        return arch;

    }

    public void Item() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case INSTRUCTION:
            case PSEUDO:
                Instruction();
                break;
            case ENUM:
                Enum();
                break;
            case ENUM_SUB:
                EnumSubset();
                break;
            case FORMAT:
                FormatDecl();
                break;
            case OPERAND_TYPE:
                OperandTypeDecl();
                break;
            case SUBROUTINE:
            case INLINE:
            case EXTERNAL:
                Subroutine();
                break;
            case ADDR_MODE:
                AddrModeDecl();
                break;
            case ADDR_SET:
                AddrSetDecl();
                break;
            case GLOBAL:
                Global();
                break;
            default:
                jj_la1[1] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public void Instruction() throws ParseException {
        Token n;
        AddrModeUse am;
        List<Stmt> s = new LinkedList<Stmt>();
        List<Property> p = new LinkedList<Property>();
        FormatDecl e;
        boolean pseudo = false;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case PSEUDO:
                jj_consume_token(PSEUDO);
                pseudo = true;
                break;
            default:
                jj_la1[2] = jj_gen;
        }
        jj_consume_token(INSTRUCTION);
        n = jj_consume_token(STRING_LITERAL);
        am = AddrModeUse(n);
        jj_consume_token(LBRACKET);
        label_2:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ENCODING:
                    break;
                default:
                    jj_la1[3] = jj_gen;
                    break label_2;
            }
            e = Encoding(n);
            am.addEncoding(e);
        }
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PROPERTY:
                    break;
                default:
                    jj_la1[4] = jj_gen;
                    break label_3;
            }
            Property(p);
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case EXECUTE:
                s = Execute(s);
                break;
            default:
                jj_la1[5] = jj_gen;
        }
        jj_consume_token(RBRACKET);
        arch.addInstruction(new InstrDecl(pseudo, n, am, p, s));
    }

    public void Enum() throws ParseException {
        Token n;
        SymbolMapping m;
        jj_consume_token(ENUM);
        n = jj_consume_token(IDENTIFIER);
        m = new SymbolMapping(n);
        jj_consume_token(LBRACKET);
        MappingSetElem(m);
        label_4:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[6] = jj_gen;
                    break label_4;
            }
            jj_consume_token(COMMA);
            MappingSetElem(m);
        }
        jj_consume_token(RBRACKET);
        arch.addEnum(new EnumDecl(n, m));
    }

    public void EnumSubset() throws ParseException {
        Token n;
        EnumTypeRef t;
        SymbolMapping m;
        jj_consume_token(ENUM_SUB);
        n = jj_consume_token(IDENTIFIER);
        jj_consume_token(78);
        t = EnumType();
        m = new SymbolMapping(n);
        jj_consume_token(LBRACKET);
        MappingSetElem(m);
        label_5:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[7] = jj_gen;
                    break label_5;
            }
            jj_consume_token(COMMA);
            MappingSetElem(m);
        }
        jj_consume_token(RBRACKET);
        arch.addEnum(new EnumDecl.Subset(n, t, m));
    }

    public AddrModeUse AddrModeUse(Token n) throws ParseException {
        List<AddrModeDecl.Operand> o;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 78:
                jj_consume_token(78);
                n = jj_consume_token(IDENTIFIER);
                return new AddrModeUse(n, null);
            default:
                jj_la1[8] = jj_gen;
                o = Operands();
                return new AddrModeUse(null, new AddrModeDecl(n, o));
        }
    }

    public Property Property(List<Property> pl) throws ParseException {
        Property p;
        Token name, v;
        TypeRef t;
        jj_consume_token(PROPERTY);
        name = jj_consume_token(IDENTIFIER);
        jj_consume_token(78);
        t = Type();
        jj_consume_token(EQUALS);
        v = Value();
        jj_consume_token(SEMI);
        p = new Property(name, t, v);
        if (pl != null) pl.add(p);
        return p;

    }

    public Token Value() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case STRING_LITERAL:
                t = jj_consume_token(STRING_LITERAL);
                break;
            case IDENTIFIER:
                t = jj_consume_token(IDENTIFIER);
                break;
            case BOOLEAN_LITERAL:
                t = jj_consume_token(BOOLEAN_LITERAL);
                break;
            case INTEGER_LITERAL:
                t = jj_consume_token(INTEGER_LITERAL);
                break;
            default:
                jj_la1[9] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return t;

    }

    public void Global() throws ParseException {
        Token n;
        TypeRef t;
        jj_consume_token(GLOBAL);
        n = jj_consume_token(IDENTIFIER);
        jj_consume_token(78);
        t = Type();
        jj_consume_token(SEMI);
        arch.addGlobal(n, t);
    }

    public void AddrModeDecl() throws ParseException {
        Token n;
        AddrModeDecl amd;
        Property p;
        List<AddrModeDecl.Operand> o;
        FormatDecl e;
        jj_consume_token(ADDR_MODE);
        n = jj_consume_token(IDENTIFIER);
        o = Operands();
        amd = new AddrModeDecl(n, o);
        jj_consume_token(LBRACKET);
        label_6:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ENCODING:
                case PROPERTY:
                    break;
                default:
                    jj_la1[10] = jj_gen;
                    break label_6;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PROPERTY:
                    p = Property(null);
                    amd.addProperty(p);
                    break;
                case ENCODING:
                    e = Encoding(n);
                    amd.addEncoding(e);
                    break;
                default:
                    jj_la1[11] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        jj_consume_token(RBRACKET);
        arch.addAddressingMode(amd);
    }

    public void AddrSetDecl() throws ParseException {
        Token n;
        List<Token> l = new LinkedList<Token>();
        Token e;
        jj_consume_token(ADDR_SET);
        n = jj_consume_token(IDENTIFIER);
        jj_consume_token(LBRACKET);
        e = jj_consume_token(IDENTIFIER);
        l.add(e);
        label_7:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[12] = jj_gen;
                    break label_7;
            }
            jj_consume_token(COMMA);
            e = jj_consume_token(IDENTIFIER);
            l.add(e);
        }
        jj_consume_token(RBRACKET);
        arch.addAddressingModeSet(new AddrModeSetDecl(n, l));
    }

    public FormatDecl Encoding(Token n) throws ParseException {
        FormatDecl d;
        FormatDecl.Cond ec;
        jj_consume_token(ENCODING);
        jj_consume_token(EQUALS);
        d = Format(n);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WHEN:
                ec = EncodingCond();
                d.setCond(ec);
                break;
            default:
                jj_la1[13] = jj_gen;
        }
        return d;

    }

    public FormatDecl.Cond EncodingCond() throws ParseException {
        Token n;
        Expr e;
        jj_consume_token(WHEN);
        n = jj_consume_token(IDENTIFIER);
        jj_consume_token(EQUAL);
        e = Expr();
        return new FormatDecl.Cond(n, e);

    }

    public List<Stmt> Execute(List<Stmt> s) throws ParseException {
        jj_consume_token(EXECUTE);
        Block(s);
        return s;

    }

    public void FormatDecl() throws ParseException {
        Token n;
        FormatDecl d;
        jj_consume_token(FORMAT);
        n = jj_consume_token(IDENTIFIER);
        jj_consume_token(EQUALS);
        d = Format(n);
        arch.addEncoding(d);
    }

    public void OperandTypeDecl() throws ParseException {
        Token n;
        OperandTypeDecl d;
        jj_consume_token(OPERAND_TYPE);
        n = jj_consume_token(IDENTIFIER);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 79:
                d = SimpleOperandType(n);
                break;
            case LBRACKET:
                d = CompoundOperandType(n);
                break;
            default:
                jj_la1[14] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        arch.addOperand(d);
    }

    public OperandTypeDecl SimpleOperandType(Token n) throws ParseException {
        TypeRef t;
        Token b, l = null, h = null;
        OperandTypeDecl d;
        jj_consume_token(79);
        b = jj_consume_token(INTEGER_LITERAL);
        jj_consume_token(80);
        jj_consume_token(78);
        t = Type();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 79:
                jj_consume_token(79);
                l = jj_consume_token(INTEGER_LITERAL);
                jj_consume_token(COMMA);
                h = jj_consume_token(INTEGER_LITERAL);
                jj_consume_token(80);
                break;
            default:
                jj_la1[15] = jj_gen;
        }
        d = new OperandTypeDecl.Value(n, b, t, l, h);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LBRACKET:
                OperandBody(d);
                break;
            case SEMI:
                jj_consume_token(SEMI);
                break;
            default:
                jj_la1[16] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return d;

    }

    public OperandTypeDecl CompoundOperandType(Token n) throws ParseException {
        OperandTypeDecl.Compound cd = new OperandTypeDecl.Compound(n);
        OperandBody(cd);
        return cd;

    }

    public void OperandBody(OperandTypeDecl td) throws ParseException {
        jj_consume_token(LBRACKET);
        label_8:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case READ:
                case WRITE:
                case 81:
                    break;
                default:
                    jj_la1[17] = jj_gen;
                    break label_8;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case READ:
                    ReadMethod(td);
                    break;
                case WRITE:
                    WriteMethod(td);
                    break;
                case 81:
                    SubOperand(td);
                    break;
                default:
                    jj_la1[18] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        jj_consume_token(RBRACKET);
    }

    public void SubOperand(OperandTypeDecl td) throws ParseException {
        AddrModeDecl.Operand o;
        jj_consume_token(81);
        o = Operand();
        td.addSubOperand(o);
        jj_consume_token(SEMI);
    }

    public void ReadMethod(OperandTypeDecl td) throws ParseException {
        Token r;
        TypeRef tr;
        List<Stmt> s = new LinkedList<Stmt>();
        r = jj_consume_token(READ);
        jj_consume_token(78);
        tr = Type();
        Block(s);
        td.addReadDecl(r, tr, new CodeRegion(s));
    }

    public void WriteMethod(OperandTypeDecl td) throws ParseException {
        Token r;
        TypeRef tr;
        List<Stmt> s = new LinkedList<Stmt>();
        r = jj_consume_token(WRITE);
        jj_consume_token(78);
        tr = Type();
        Block(s);
        td.addWriteDecl(r, tr, new CodeRegion(s));
    }

    public void MappingSetElem(SymbolMapping m) throws ParseException {
        Token n, i;
        n = jj_consume_token(IDENTIFIER);
        jj_consume_token(EQUALS);
        i = jj_consume_token(INTEGER_LITERAL);
        m.add(n, i);
    }

    public FormatDecl Format(Token n) throws ParseException {
        Token pr = null;
        FormatDecl d;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case PRIORITY:
                jj_consume_token(PRIORITY);
                pr = jj_consume_token(INTEGER_LITERAL);
                break;
            default:
                jj_la1[19] = jj_gen;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                d = DerivedFormat(pr, n);
                break;
            case LBRACKET:
                d = NewFormat(pr, n);
                break;
            default:
                jj_la1[20] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return d;

    }

    public FormatDecl DerivedFormat(Token pr, Token n) throws ParseException {
        Token p;
        List<FormatDecl.Substitution> l = new LinkedList<FormatDecl.Substitution>();
        p = jj_consume_token(IDENTIFIER);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case WHERE:
                jj_consume_token(WHERE);
                l = SubstitutionList();
                break;
            case SEMI:
                jj_consume_token(SEMI);
                break;
            default:
                jj_la1[21] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return new FormatDecl.Derived(n, pr, p, l);

    }

    public FormatDecl NewFormat(Token pr, Token n) throws ParseException {
        List<Expr> l;
        jj_consume_token(LBRACKET);
        l = ExprList();
        jj_consume_token(RBRACKET);
        return new FormatDecl(n, pr, l);

    }

    public List<FormatDecl.Substitution> SubstitutionList() throws ParseException {
        List<FormatDecl.Substitution> l = new LinkedList<FormatDecl.Substitution>();
        FormatDecl.Substitution s;
        jj_consume_token(LBRACKET);
        s = Substitution();
        l.add(s);
        label_9:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[22] = jj_gen;
                    break label_9;
            }
            jj_consume_token(COMMA);
            s = Substitution();
            l.add(s);
        }
        jj_consume_token(RBRACKET);
        return l;

    }

    public FormatDecl.Substitution Substitution() throws ParseException {
        Token n;
        Expr e;
        n = jj_consume_token(IDENTIFIER);
        jj_consume_token(EQUALS);
        e = Expr();
        return new FormatDecl.Substitution(n, e);

    }

    public List<AddrModeDecl.Operand> Operands() throws ParseException {
        AddrModeDecl.Operand o;
        List<AddrModeDecl.Operand> l = new LinkedList<AddrModeDecl.Operand>();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                o = Operand();
                l.add(o);
                label_10:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[23] = jj_gen;
                            break label_10;
                    }
                    jj_consume_token(COMMA);
                    o = Operand();
                    l.add(o);
                }
                break;
            default:
                jj_la1[24] = jj_gen;
        }
        return l;

    }

    public AddrModeDecl.Operand Operand() throws ParseException {
        Token n;
        OperandTypeRef t;
        n = jj_consume_token(IDENTIFIER);
        jj_consume_token(78);
        t = OperandType();
        return new AddrModeDecl.Operand(n, t);

    }

    public void Subroutine() throws ParseException {
        boolean i = false;
        Token m;
        TypeRef r;
        List<SubroutineDecl.Parameter> f;
        List<Stmt> l = new LinkedList<Stmt>();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SUBROUTINE:
            case INLINE:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case INLINE:
                        jj_consume_token(INLINE);
                        i = true;
                        break;
                    default:
                        jj_la1[25] = jj_gen;
                }
                jj_consume_token(SUBROUTINE);
                m = jj_consume_token(IDENTIFIER);
                jj_consume_token(LPAREN);
                f = Params();
                jj_consume_token(RPAREN);
                jj_consume_token(78);
                r = Type();
                Block(l);
                arch.addSubroutine(new SubroutineDecl(i, m, f, r, l));
                break;
            case EXTERNAL:
                jj_consume_token(EXTERNAL);
                jj_consume_token(SUBROUTINE);
                m = jj_consume_token(IDENTIFIER);
                jj_consume_token(LPAREN);
                f = Params();
                jj_consume_token(RPAREN);
                jj_consume_token(78);
                r = Type();
                jj_consume_token(SEMI);
                arch.addSubroutine(new SubroutineDecl(i, m, f, r, null));
                break;
            default:
                jj_la1[26] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public List<SubroutineDecl.Parameter> Params() throws ParseException {
        SubroutineDecl.Parameter p;
        List<SubroutineDecl.Parameter> l = new LinkedList<SubroutineDecl.Parameter>();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                p = Param();
                l.add(p);
                label_11:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[27] = jj_gen;
                            break label_11;
                    }
                    jj_consume_token(COMMA);
                    p = Param();
                    l.add(p);
                }
                break;
            default:
                jj_la1[28] = jj_gen;
        }
        return l;

    }

    public SubroutineDecl.Parameter Param() throws ParseException {
        Token n;
        TypeRef t;
        n = jj_consume_token(IDENTIFIER);
        jj_consume_token(78);
        t = Type();
        return new SubroutineDecl.Parameter(n, t);

    }

    public Expr Expr() throws ParseException {
        Expr e;
        e = Cond_Or_Expr();
        return e;

    }

    public List<Expr> ExprList() throws ParseException {
        List<Expr> l = new LinkedList<Expr>();
        Expr e;
        e = Expr();
        l.add(e);
        label_12:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case COMMA:
                    break;
                default:
                    jj_la1[29] = jj_gen;
                    break label_12;
            }
            jj_consume_token(COMMA);
            e = Expr();
            l.add(e);
        }
        return l;

    }

    public Expr Term() throws ParseException {
        Expr e;
        if (jj_2_1(2)) {
            e = CallExpr();
        } else if (jj_2_2(2)) {
            e = DotExpr();
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IDENTIFIER:
                    e = VarUse();
                    break;
                case INTEGER_LITERAL:
                case BOOLEAN_LITERAL:
                    e = Literal();
                    break;
                case READ:
                    e = ReadExpr();
                    break;
                case LPAREN:
                    jj_consume_token(LPAREN);
                    e = Expr();
                    jj_consume_token(RPAREN);
                    break;
                default:
                    jj_la1[30] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        label_13:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 79:
                    break;
                default:
                    jj_la1[31] = jj_gen;
                    break label_13;
            }
            e = Index(e);
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 78:
                e = Conversion(e);
                break;
            default:
                jj_la1[32] = jj_gen;
        }
        return e;

    }

    public Expr Conversion(Expr e) throws ParseException {
        TypeRef t;
        jj_consume_token(78);
        t = Type();
        return new ConversionExpr(e, t);

    }

    public Expr VarUse() throws ParseException {
        Token t;
        t = jj_consume_token(IDENTIFIER);
        return new VarExpr(t);

    }

    public Expr DotExpr() throws ParseException {
        Token o, f;
        o = jj_consume_token(IDENTIFIER);
        jj_consume_token(82);
        f = jj_consume_token(IDENTIFIER);
        return new DotExpr(new VarExpr(o), f);

    }

    public Expr Literal() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case INTEGER_LITERAL:
                t = jj_consume_token(INTEGER_LITERAL);
                return new Literal.IntExpr(t);
            case BOOLEAN_LITERAL:
                t = jj_consume_token(BOOLEAN_LITERAL);
                return new Literal.BoolExpr(t);
            default:
                jj_la1[33] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }

    }

    public Expr ReadExpr() throws ParseException {
        Token r, o;
        TypeRef t = null;
        r = jj_consume_token(READ);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 78:
                jj_consume_token(78);
                t = Type();
                break;
            default:
                jj_la1[34] = jj_gen;
        }
        jj_consume_token(LPAREN);
        o = jj_consume_token(IDENTIFIER);
        jj_consume_token(RPAREN);
        return new ReadExpr(r, t, o);

    }

    public Expr CallExpr() throws ParseException {
        Token t;
        List<Expr> l;
        t = jj_consume_token(IDENTIFIER);
        l = Parameters();
        return new CallExpr(t, l);

    }

    public List<Expr> Parameters() throws ParseException {
        List<Expr> l = new LinkedList<Expr>();
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case INTEGER_LITERAL:
            case READ:
            case BOOLEAN_LITERAL:
            case LPAREN:
            case ADD:
            case SUB:
            case NOT:
            case B_COMP:
            case IDENTIFIER:
                l = ExprList();
                break;
            default:
                jj_la1[35] = jj_gen;
        }
        jj_consume_token(RPAREN);
        return l;

    }

    public Stmt Statement() throws ParseException {
        Stmt s;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LOCAL:
                s = LocalDecl();
                break;
            case IF:
                s = IfStatement();
                break;
            default:
                jj_la1[36] = jj_gen;
                if (jj_2_3(2147483647)) {
                    s = Assignment();
                } else {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case IDENTIFIER:
                            s = CallStmt();
                            break;
                        case RETURN:
                            s = ReturnStmt();
                            break;
                        case WRITE:
                            s = WriteStmt();
                            break;
                        default:
                            jj_la1[37] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
        }
        return s;

    }

    public DeclStmt LocalDecl() throws ParseException {
        Token n;
        TypeRef t;
        Expr e;
        jj_consume_token(LOCAL);
        n = jj_consume_token(IDENTIFIER);
        jj_consume_token(78);
        t = Type();
        jj_consume_token(EQUALS);
        e = Expr();
        jj_consume_token(SEMI);
        return new DeclStmt(n, t, e);

    }

    public IfStmt IfStatement() throws ParseException {
        Expr c;
        List<Stmt> t = new LinkedList<Stmt>(), f = new LinkedList<Stmt>();
        jj_consume_token(IF);
        jj_consume_token(LPAREN);
        c = Expr();
        jj_consume_token(RPAREN);
        SingleStatement(t);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ELSE:
                jj_consume_token(ELSE);
                SingleStatement(f);
                break;
            default:
                jj_la1[38] = jj_gen;
        }
        return new IfStmt(c, t, f);

    }

    public CallStmt CallStmt() throws ParseException {
        Token t;
        List<Expr> l;
        t = jj_consume_token(IDENTIFIER);
        l = Parameters();
        jj_consume_token(SEMI);
        return new CallStmt(t, l);

    }

    public ReturnStmt ReturnStmt() throws ParseException {
        Expr e;
        jj_consume_token(RETURN);
        e = Expr();
        jj_consume_token(SEMI);
        return new ReturnStmt(e);

    }

    public WriteStmt WriteStmt() throws ParseException {
        Token w, o;
        TypeRef t = null;
        Expr e;
        w = jj_consume_token(WRITE);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 78:
                jj_consume_token(78);
                t = Type();
                break;
            default:
                jj_la1[39] = jj_gen;
        }
        jj_consume_token(LPAREN);
        o = jj_consume_token(IDENTIFIER);
        jj_consume_token(COMMA);
        e = Expr();
        jj_consume_token(RPAREN);
        jj_consume_token(SEMI);
        return new WriteStmt(w, t, o, e);

    }

    public void SingleStatement(List<Stmt> l) throws ParseException {
        Stmt s;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case INTEGER_LITERAL:
            case READ:
            case WRITE:
            case LOCAL:
            case IF:
            case RETURN:
            case BOOLEAN_LITERAL:
            case LPAREN:
            case ADD:
            case SUB:
            case NOT:
            case B_COMP:
            case IDENTIFIER:
                s = Statement();
                l.add(s);
                break;
            case LBRACKET:
                Block(l);
                break;
            default:
                jj_la1[40] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public AssignStmt Assignment() throws ParseException {
        Expr d;
        Expr e;
        d = Expr();
        jj_consume_token(EQUALS);
        e = Expr();
        jj_consume_token(SEMI);
        return new AssignStmt(d, e);

    }

    public List<Stmt> Block(List<Stmt> l) throws ParseException {
        Stmt s;
        jj_consume_token(LBRACKET);
        label_14:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case INTEGER_LITERAL:
                case READ:
                case WRITE:
                case LOCAL:
                case IF:
                case RETURN:
                case BOOLEAN_LITERAL:
                case LPAREN:
                case ADD:
                case SUB:
                case NOT:
                case B_COMP:
                case IDENTIFIER:
                    break;
                default:
                    jj_la1[41] = jj_gen;
                    break label_14;
            }
            s = Statement();
            l.add(s);
        }
        jj_consume_token(RBRACKET);
        return l;

    }

    public Expr Index(Expr e) throws ParseException {
        Expr et;
        Token t1, t2;
        jj_consume_token(79);
        if (jj_2_4(2)) {
            t1 = jj_consume_token(INTEGER_LITERAL);
            jj_consume_token(78);
            t2 = jj_consume_token(INTEGER_LITERAL);
            e = new FixedRangeExpr(e, t1, t2);
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case INTEGER_LITERAL:
                case READ:
                case BOOLEAN_LITERAL:
                case LPAREN:
                case ADD:
                case SUB:
                case NOT:
                case B_COMP:
                case IDENTIFIER:
                    et = Expr();
                    e = new IndexExpr(e, et);
                    break;
                default:
                    jj_la1[42] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        jj_consume_token(80);
        return e;

    }

    public Expr Cond_Or_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = Cond_Xor_Expr();
        label_15:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case OR:
                    break;
                default:
                    jj_la1[43] = jj_gen;
                    break label_15;
            }
            tok = jj_consume_token(OR);
            et = Cond_Xor_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr Cond_Xor_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = Cond_And_Expr();
        label_16:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case XOR:
                    break;
                default:
                    jj_la1[44] = jj_gen;
                    break label_16;
            }
            tok = jj_consume_token(XOR);
            et = Cond_And_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr Cond_And_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = Or_Expr();
        label_17:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case AND:
                    break;
                default:
                    jj_la1[45] = jj_gen;
                    break label_17;
            }
            tok = jj_consume_token(AND);
            et = Or_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr Or_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = Xor_Expr();
        label_18:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case B_OR:
                    break;
                default:
                    jj_la1[46] = jj_gen;
                    break label_18;
            }
            tok = jj_consume_token(B_OR);
            et = Xor_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr Xor_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = And_Expr();
        label_19:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case B_XOR:
                    break;
                default:
                    jj_la1[47] = jj_gen;
                    break label_19;
            }
            tok = jj_consume_token(B_XOR);
            et = And_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr And_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = Equ_Expr();
        label_20:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case B_AND:
                    break;
                default:
                    jj_la1[48] = jj_gen;
                    break label_20;
            }
            tok = jj_consume_token(B_AND);
            et = Equ_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr Equ_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = Rel_Expr();
        label_21:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case EQUAL:
                case NOTEQUAL:
                    break;
                default:
                    jj_la1[49] = jj_gen;
                    break label_21;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case EQUAL:
                    tok = jj_consume_token(EQUAL);
                    break;
                case NOTEQUAL:
                    tok = jj_consume_token(NOTEQUAL);
                    break;
                default:
                    jj_la1[50] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            et = Rel_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr Rel_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = Shift_Expr();
        label_22:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LESS:
                case LESSEQ:
                case GREATER:
                case GREATEREQ:
                    break;
                default:
                    jj_la1[51] = jj_gen;
                    break label_22;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LESS:
                    tok = jj_consume_token(LESS);
                    break;
                case GREATER:
                    tok = jj_consume_token(GREATER);
                    break;
                case LESSEQ:
                    tok = jj_consume_token(LESSEQ);
                    break;
                case GREATEREQ:
                    tok = jj_consume_token(GREATEREQ);
                    break;
                default:
                    jj_la1[52] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            et = Shift_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr Shift_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = Add_Expr();
        label_23:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case SHIFTLEFT:
                case SHIFTRIGHT:
                    break;
                default:
                    jj_la1[53] = jj_gen;
                    break label_23;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case SHIFTLEFT:
                    tok = jj_consume_token(SHIFTLEFT);
                    break;
                case SHIFTRIGHT:
                    tok = jj_consume_token(SHIFTRIGHT);
                    break;
                default:
                    jj_la1[54] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            et = Add_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr Add_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = Mul_Expr();
        label_24:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ADD:
                case SUB:
                    break;
                default:
                    jj_la1[55] = jj_gen;
                    break label_24;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ADD:
                    tok = jj_consume_token(ADD);
                    break;
                case SUB:
                    tok = jj_consume_token(SUB);
                    break;
                default:
                    jj_la1[56] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            et = Mul_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr Mul_Expr() throws ParseException {
        Expr e, et;
        Token tok;
        e = Un_Expr();
        label_25:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case MUL:
                case DIV:
                case MOD:
                    break;
                default:
                    jj_la1[57] = jj_gen;
                    break label_25;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case MUL:
                    tok = jj_consume_token(MUL);
                    break;
                case DIV:
                    tok = jj_consume_token(DIV);
                    break;
                case MOD:
                    tok = jj_consume_token(MOD);
                    break;
                default:
                    jj_la1[58] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            et = Un_Expr();
            e = new BinOpExpr(e, tok, et);
        }
        return e;

    }

    public Expr Un_Expr() throws ParseException {
        Expr e;
        Token tok;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ADD:
            case SUB:
            case NOT:
            case B_COMP:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case B_COMP:
                        tok = jj_consume_token(B_COMP);
                        break;
                    case NOT:
                        tok = jj_consume_token(NOT);
                        break;
                    case SUB:
                        tok = jj_consume_token(SUB);
                        break;
                    case ADD:
                        tok = jj_consume_token(ADD);
                        break;
                    default:
                        jj_la1[59] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                e = Term();
                e = new UnOpExpr(tok, e);
                break;
            case INTEGER_LITERAL:
            case READ:
            case BOOLEAN_LITERAL:
            case LPAREN:
            case IDENTIFIER:
                e = Term();
                break;
            default:
                jj_la1[60] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return e;

    }

    public TypeRef Type() throws ParseException {
        Token t;
        HashMap<String, List> dims = new HashMap<String, List>();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ADD:
            case SUB:
                SignDimension(dims);
                break;
            default:
                jj_la1[61] = jj_gen;
        }
        t = jj_consume_token(IDENTIFIER);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 82:
                SizeDimension(dims);
                break;
            default:
                jj_la1[62] = jj_gen;
        }
        if (jj_2_5(2)) {
            TypesDimension(dims, "types");
        } else {
        }
        return new TypeRef(t, dims);

    }

    public void SignDimension(HashMap<String, List> dims) throws ParseException {
        Token s;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ADD:
                s = jj_consume_token(ADD);
                break;
            case SUB:
                s = jj_consume_token(SUB);
                break;
            default:
                jj_la1[63] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        List l = new LinkedList();
        l.add(s);
        dims.put("sign", l);
    }

    public void SizeDimension(HashMap<String, List> dims) throws ParseException {
        Token w;
        jj_consume_token(82);
        w = jj_consume_token(INTEGER_LITERAL);
        List l = new LinkedList();
        l.add(w);
        dims.put("size", l);
    }

    public void TypesDimension(HashMap<String, List> dims, String n) throws ParseException {
        List ty = new LinkedList();
        TypeRef tr;
        jj_consume_token(LESS);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ADD:
            case SUB:
            case IDENTIFIER:
                tr = Type();
                ty.add(tr);
                label_26:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[64] = jj_gen;
                            break label_26;
                    }
                    jj_consume_token(COMMA);
                    tr = Type();
                    ty.add(tr);
                }
                break;
            default:
                jj_la1[65] = jj_gen;
        }
        jj_consume_token(GREATER);
        dims.put(n, ty);
    }

    public OperandTypeRef OperandType() throws ParseException {
        Token t;
        t = jj_consume_token(IDENTIFIER);
        return new OperandTypeRef(t);

    }

    public EnumTypeRef EnumType() throws ParseException {
        Token t;
        t = jj_consume_token(IDENTIFIER);
        return new EnumTypeRef(t);

    }

    private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    private boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_2();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(1, xla);
        }
    }

    private boolean jj_2_3(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_3();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(2, xla);
        }
    }

    private boolean jj_2_4(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_4();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(3, xla);
        }
    }

    private boolean jj_2_5(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_5();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(4, xla);
        }
    }

    private boolean jj_3R_27() {
        if (jj_scan_token(IDENTIFIER)) return true;
        return jj_3R_31();
    }

    private boolean jj_3R_42() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(58)) {
            jj_scanpos = xsp;
            if (jj_scan_token(59)) return true;
        }
        return false;
    }

    private boolean jj_3R_38() {
        if (jj_scan_token(XOR)) return true;
        return jj_3R_37();
    }

    private boolean jj_3_5() {
        return jj_3R_30();
    }

    private boolean jj_3R_78() {
        return jj_3R_80();
    }

    private boolean jj_3R_70() {
        if (jj_scan_token(READ)) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_75()) jj_scanpos = xsp;
        if (jj_scan_token(LPAREN)) return true;
        if (jj_scan_token(IDENTIFIER)) return true;
        return jj_scan_token(RPAREN);
    }

    private boolean jj_3R_34() {
        if (jj_3R_37()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_38()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_39() {
        return jj_3R_42();
    }

    private boolean jj_3R_36() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_39()) jj_scanpos = xsp;
        if (jj_scan_token(IDENTIFIER)) return true;
        xsp = jj_scanpos;
        if (jj_3R_78()) jj_scanpos = xsp;
        xsp = jj_scanpos;
        if (jj_3_5()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_74() {
        return jj_scan_token(BOOLEAN_LITERAL);
    }

    private boolean jj_3R_35() {
        if (jj_scan_token(OR)) return true;
        return jj_3R_34();
    }

    private boolean jj_3R_73() {
        return jj_scan_token(INTEGER_LITERAL);
    }

    private boolean jj_3R_69() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_73()) {
            jj_scanpos = xsp;
            if (jj_3R_74()) return true;
        }
        return false;
    }

    private boolean jj_3R_32() {
        if (jj_3R_34()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_35()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_28() {
        if (jj_scan_token(IDENTIFIER)) return true;
        if (jj_scan_token(82)) return true;
        return jj_scan_token(IDENTIFIER);
    }

    private boolean jj_3R_60() {
        return jj_3R_61();
    }

    private boolean jj_3R_81() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_29();
    }

    private boolean jj_3R_59() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(67)) {
            jj_scanpos = xsp;
            if (jj_scan_token(66)) {
                jj_scanpos = xsp;
                if (jj_scan_token(59)) {
                    jj_scanpos = xsp;
                    if (jj_scan_token(58)) return true;
                }
            }
        }
        return jj_3R_61();
    }

    private boolean jj_3R_76() {
        return jj_3R_29();
    }

    private boolean jj_3R_57() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_59()) {
            jj_scanpos = xsp;
            if (jj_3R_60()) return true;
        }
        return false;
    }

    private boolean jj_3R_68() {
        return jj_scan_token(IDENTIFIER);
    }

    private boolean jj_3_4() {
        if (jj_scan_token(INTEGER_LITERAL)) return true;
        if (jj_scan_token(78)) return true;
        return jj_scan_token(INTEGER_LITERAL);
    }

    private boolean jj_3R_71() {
        if (jj_scan_token(79)) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_4()) {
            jj_scanpos = xsp;
            if (jj_3R_76()) return true;
        }
        return jj_scan_token(80);
    }

    private boolean jj_3R_58() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(60)) {
            jj_scanpos = xsp;
            if (jj_scan_token(61)) {
                jj_scanpos = xsp;
                if (jj_scan_token(62)) return true;
            }
        }
        return jj_3R_57();
    }

    private boolean jj_3R_72() {
        if (jj_scan_token(78)) return true;
        return jj_3R_36();
    }

    private boolean jj_3R_55() {
        if (jj_3R_57()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_58()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_67() {
        return jj_3R_72();
    }

    private boolean jj_3R_66() {
        return jj_3R_71();
    }

    private boolean jj_3R_65() {
        if (jj_scan_token(LPAREN)) return true;
        if (jj_3R_29()) return true;
        return jj_scan_token(RPAREN);
    }

    private boolean jj_3R_64() {
        return jj_3R_70();
    }

    private boolean jj_3R_63() {
        return jj_3R_69();
    }

    private boolean jj_3R_56() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(58)) {
            jj_scanpos = xsp;
            if (jj_scan_token(59)) return true;
        }
        return jj_3R_55();
    }

    private boolean jj_3R_62() {
        return jj_3R_68();
    }

    private boolean jj_3_2() {
        return jj_3R_28();
    }

    private boolean jj_3_1() {
        return jj_3R_27();
    }

    private boolean jj_3R_53() {
        if (jj_3R_55()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_56()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_61() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_1()) {
            jj_scanpos = xsp;
            if (jj_3_2()) {
                jj_scanpos = xsp;
                if (jj_3R_62()) {
                    jj_scanpos = xsp;
                    if (jj_3R_63()) {
                        jj_scanpos = xsp;
                        if (jj_3R_64()) {
                            jj_scanpos = xsp;
                            if (jj_3R_65()) return true;
                        }
                    }
                }
            }
        }
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_66()) {
                jj_scanpos = xsp;
                break;
            }
        }
        xsp = jj_scanpos;
        if (jj_3R_67()) jj_scanpos = xsp;
        return false;
    }

    private boolean jj_3R_54() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(56)) {
            jj_scanpos = xsp;
            if (jj_scan_token(57)) return true;
        }
        return jj_3R_53();
    }

    private boolean jj_3R_79() {
        if (jj_3R_29()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_81()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_51() {
        if (jj_3R_53()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_54()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_52() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(70)) {
            jj_scanpos = xsp;
            if (jj_scan_token(72)) {
                jj_scanpos = xsp;
                if (jj_scan_token(71)) {
                    jj_scanpos = xsp;
                    if (jj_scan_token(73)) return true;
                }
            }
        }
        return jj_3R_51();
    }

    private boolean jj_3R_29() {
        return jj_3R_32();
    }

    private boolean jj_3R_82() {
        if (jj_scan_token(COMMA)) return true;
        return jj_3R_36();
    }

    private boolean jj_3R_49() {
        if (jj_3R_51()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_52()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_50() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(68)) {
            jj_scanpos = xsp;
            if (jj_scan_token(69)) return true;
        }
        return jj_3R_49();
    }

    private boolean jj_3R_47() {
        if (jj_3R_49()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_50()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_48() {
        if (jj_scan_token(B_AND)) return true;
        return jj_3R_47();
    }

    private boolean jj_3R_45() {
        if (jj_3R_47()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_48()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3_3() {
        if (jj_3R_29()) return true;
        return jj_scan_token(EQUALS);
    }

    private boolean jj_3R_46() {
        if (jj_scan_token(B_XOR)) return true;
        return jj_3R_45();
    }

    private boolean jj_3R_43() {
        if (jj_3R_45()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_46()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_33() {
        if (jj_3R_36()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_82()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_44() {
        if (jj_scan_token(B_OR)) return true;
        return jj_3R_43();
    }

    private boolean jj_3R_77() {
        return jj_3R_79();
    }

    private boolean jj_3R_40() {
        if (jj_3R_43()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_44()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private boolean jj_3R_30() {
        if (jj_scan_token(LESS)) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_33()) jj_scanpos = xsp;
        return jj_scan_token(GREATER);
    }

    private boolean jj_3R_75() {
        if (jj_scan_token(78)) return true;
        return jj_3R_36();
    }

    private boolean jj_3R_31() {
        if (jj_scan_token(LPAREN)) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_77()) jj_scanpos = xsp;
        return jj_scan_token(RPAREN);
    }

    private boolean jj_3R_41() {
        if (jj_scan_token(AND)) return true;
        return jj_3R_40();
    }

    private boolean jj_3R_80() {
        if (jj_scan_token(82)) return true;
        return jj_scan_token(INTEGER_LITERAL);
    }

    private boolean jj_3R_37() {
        if (jj_3R_40()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_41()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    public ISDLParserTokenManager token_source;
    SimpleCharStream jj_input_stream;
    public Token token, jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    public boolean lookingAhead = false;
    private boolean jj_semLA;
    private int jj_gen;
    private final int[] jj_la1 = new int[66];
    private static int[] jj_la1_0;
    private static int[] jj_la1_1;
    private static int[] jj_la1_2;

    static {
        jj_la1_0();
        jj_la1_1();
        jj_la1_2();
    }

    private static void jj_la1_0() {
        jj_la1_0 = new int[] { 0x7e80000, 0x7e80000, 0x0, 0x80000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x42000,
                0x80000000, 0x80000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18000000, 0x18000000, 0x40000000, 0x0,
                0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8002000, 0x0, 0x0, 0x2000, 0x0,
                0x8002000, 0x0, 0x10000000, 0x0, 0x0, 0x18002000, 0x18002000, 0x8002000, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8002000, 0x0, 0x0, 0x0,
                0x0, 0x0, };
    }

    private static void jj_la1_1() {
        jj_la1_1 = new int[] { 0x4e04, 0x4e04, 0x4000, 0x0, 0x10000, 0x1, 0x100000, 0x100000, 0x0, 0x2000,
                0x10000, 0x10000, 0x100000, 0x8000, 0x20000, 0x0, 0x820000, 0x0, 0x0, 0x0, 0x20000, 0x800000,
                0x100000, 0x100000, 0x0, 0x400, 0xe00, 0x100000, 0x0, 0x100000, 0x202000, 0x0, 0x0, 0x2000,
                0x0, 0xc202000, 0x12, 0x1000, 0x20, 0x0, 0xc223012, 0xc203012, 0xc202000, 0x80, 0x100, 0x40,
                0x0, 0x0, 0x80000000, 0x0, 0x0, 0x0, 0x0, 0x3000000, 0x3000000, 0xc000000, 0xc000000,
                0x70000000, 0x70000000, 0xc000000, 0xc202000, 0xc000000, 0x0, 0xc000000, 0x100000,
                0xc000000, };
    }

    private static void jj_la1_2() {
        jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4000, 0x800, 0x0, 0x0, 0x0, 0x0,
                0x8000, 0x8000, 0x0, 0x20000, 0x20000, 0x0, 0x800, 0x0, 0x0, 0x0, 0x800, 0x0, 0x0, 0x0, 0x800,
                0x0, 0x800, 0x8000, 0x4000, 0x0, 0x4000, 0x80c, 0x0, 0x800, 0x0, 0x4000, 0x80c, 0x80c, 0x80c,
                0x0, 0x0, 0x0, 0x1, 0x2, 0x0, 0x30, 0x30, 0x3c0, 0x3c0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc,
                0x80c, 0x0, 0x40000, 0x0, 0x0, 0x800, };
    }

    private final JJCalls[] jj_2_rtns = new JJCalls[5];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    public ISDLParser(InputStream stream) {
        this(stream, null);
    }

    public ISDLParser(InputStream stream, String encoding) {
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new ISDLParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 66; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(InputStream stream) {
        ReInit(stream);
    }

    public void ReInit(InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 66; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public ISDLParser(Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new ISDLParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 66; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 66; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public ISDLParser(ISDLParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 66; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(ISDLParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 66; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    private static final class LookaheadSuccess extends Error {

    }

    private final LookaheadSuccess jj_ls = new LookaheadSuccess();

    private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
        return false;
    }

    public Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    public Token getToken(int index) {
        Token t = lookingAhead ? jj_scanpos : token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk() {
        if ((jj_nt = token.next) == null) return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else return (jj_ntk = jj_nt.kind);
    }

    private Vector jj_expentries = new Vector();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            System.arraycopy(jj_lasttokens, 0, jj_expentry, 0, jj_endpos);
            boolean exists = false;
            for (Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
                int[] oldentry = (int[])(e.nextElement());
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists) break;
                }
            }
            if (!exists) jj_expentries.addElement(jj_expentry);
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[83];
        for (int i = 0; i < 83; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 66; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 83; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[])jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 5; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                            case 0:
                                jj_3_1();
                                break;
                            case 1:
                                jj_3_2();
                                break;
                            case 2:
                                jj_3_3();
                                break;
                            case 3:
                                jj_3_4();
                                break;
                            case 4:
                                jj_3_5();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls {

        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
